---
title: 常见的网格库和使用
tags: 工具
categories: 学习笔记
date: 2019-02-23 17:38:19
---

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<script type="text/javascript" async
  src="https://wujilingfeng.top/MathJax/MathJax.js?config=TeX-AMS_CHTML">
</script>
本文介绍网格处理库



<!--more-->



#### openmesh

先给一份写的[pdf](./openmesh.pdf),以后有时间写博客版的。openmesh的用法（包含部分图像处理库libigl)

#### libcell

libcell可以表示n维流形，并且不仅可以表示单形，其他任何形式也可以。（其实它的要求非常宽松，甚至不是流形的图也可以表示）

但是libcell只保存了三个层次的信息。vertex(0维子流形)，face(n-1维流形)，cell（n维流形）

cell是你要表示的n维流形的开集，face是cell的边界。

或许把n=2，再叙述一边你能理解上面的话。

n=2说明你要表示一张曲面，那么cell是多边形，face是边，vertex是点

n=3说明你要表示三维体结构，那么cell是一个多面体，face是面，vertex是点。

*当你表示的流形结构不是单形时，且不确定，那么理论上这个流形的结构你只能知道vertex,face,cell的信息。*

*但当你要表示的流形结构时单形时，理论上你完全可以推导出它每层的信息。*

* 为了提升速度，libcell内置高效的节点容器Node。了解它能让你接触并写出内部高效的函数

```c++

Node* temp_node;
for(Node n_it=*temp_node;*n_it!=NULL;n_it++)
{}
//以上是对Node* temp_node遍历
//以下直接对结构体Node遍历，两者一样
Node temp_node1;
for(Node n_it=temp_ndoe1;*n_it!=NULL;n_it++)
{
    
}
```

想要了解更多Node接口，可以在tools_node.h中定义了Node常用的函数，lib_cell_iterator.h中对Node进行了++,*的运算符重载。

当然为了不增加你的学习成本，你完全可以不用管它。(这个容器完全以外部依赖的方式存在，并且只有简单几个函数，并没有多少学习成本，而且你完全可以copy代码，用在别的地方)

* libcell还有仿openmesh的网格遍历接口

  ```c++
  
  for(auto fit=mesh.faces.begin();fit!=mesh.faces.end();fit++)//对面的遍历 
  {
      for(auto fvit=mesh.fv_begin(&mesh,*fit->second);fvit!=mesh.fv_begin(&mesh,*fit->second);fvit++)//面上点的遍历
      {
          （*fvit）//点(结构体实例，对他修改不会影响到真实的点)
            quote(cvit)//点(引用指针，直接修改的话会影响到实体)
      }
  }
  ```

  还可以用下面的遍历方式

  ```c++
  for(auto fit=mesh.faces.begin();fit!=mesh.faces.end();fit++)//对面的遍历 
  {
  	for(int i=0;i<fit->second->vertices_size;i++)//面上点的遍历
      {
          (template_v*)fit->second->vertices[i]//点
      }
  }
  ```

  ```c++
  for(auto cit=mesh.cells.begin();cit!=mesh.cells.end();cit++)//对cell的遍历 
  {
      for(auto cvit=mesh.cv_begin(&mesh,*cit->second);cvit!=mesh.fv_begin(&mesh,*cit->second);fvit++)//cell对点的遍历
      {
          (*cvit)//点(结构体)
          quote(cvit)//点(引用指针，直接修改的话会影响到实体)
      }
  }
  //还可以用以下方法
  for(auto cit=mesh.cells.begin();cit!=mesh.cells.end();cit++)//对cell的遍历 
  {
      for(int i=0;i<cit->second->vertices_size;i++)//cell对点的遍历
      {
          (template_v*)cit->second->vertices[i]//点
      }
  }
  for(auto cit=mesh.cells.begin();cit!=mesh.cells.end();cit++)//对cell的遍历 
  {
      for(auto cfit=mesh.cf_begin(&mesh,*cit->second);cfit!=mesh.cf_begin(&mesh,*cit->second);cfit++)//cell对face的遍历
      {
          (*cfit)//face(结构体实例)
          quote(cfit)//face指针(引用指针，直接修改的话会影响到实体)
      }
  }
  for(auto vit=mesh.vertices.begin();vit!=mesh.vertices.end();vit++)//对点的遍历
  {//点对cell的遍历
      for(auto vcit=mesh.vc_begin(&mesh,*vit);vcit!=mesh.vc_end(&mesh,*vit);vcit++)
      {
     		(*vcit)//
          quote(vcit);
      }
  }
  for(auto vit=mesh.vertices.begin();vit!=mesh.vertices.end();vit++)//点的遍历
  {
      //点对face的遍历
      for(auto vfit=mesh.vf_begin(&mesh,*vit);vfit!=mesh.vf_end(&mesh,*vit);vfit++)
      {
     		(*vfit)//
          quote(vfit);//
      }
     
  }
  ```

  ```c++
  template_f* f;
  f->halfface[0]->cell//face访问halfface,再访问到cell，更多的用法完全仿照openmesh
  ```


#### 离散网格理论

##### Definition :网格的重叠(overlap)（可以用来判断参数化的单射性）

对于网格某个点p,跟它相邻点的坐标分量作为morse函数，临界点超过两个则重叠(overlap)