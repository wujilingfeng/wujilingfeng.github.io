[{"content":"将使用 Dawn 库编写的渲染程序导出到 Web 端和本地端，需要采取不同的编译和部署策略，但核心思想是：你的 C++ 渲染逻辑（使用 WebGPU API）大部分可以保持不变，而平台特定的部分（如窗口创建、文件IO、事件处理）则需要抽象或有条件编译。\nDawn 本身是一个 C++ 库，实现了 WebGPU API 规范，并且是 Chromium 浏览器中 WebGPU 的底层实现。\n核心思想：平台无关的 WebGPU 逻辑 你的渲染程序主体应该使用 WebGPU API（通过 wgpu::Device, wgpu::Queue, wgpu::RenderPassEncoder 等）来定义渲染管线、加载资源、绘制等。这部分代码在概念上是平台无关的。\n然而，创建窗口/画布、获取 WebGPU 设备、处理用户输入等部分是与平台紧密相关的。\n1. 导出到 Web 端 (浏览器) 在 Web 端，你的 C++ 代码需要被编译成 WebAssembly (WASM)，并在浏览器环境中运行。浏览器本身提供了原生的 WebGPU API 实现（在 Chromium 中，这个实现就是基于 Dawn 的）。这意味着你不需要将 Dawn 库本身编译进你的 WASM 包，你的 WASM 直接调用浏览器提供的 WebGPU API。\n主要工具：Emscripten\n编写 C++ 渲染程序：\n你的渲染代码会调用标准的 WebGPU API（封装在 Dawn 的 C++ 头文件中，如 dawn/webgpu.h 或直接使用 wgpu 名称空间）。\n对于画布的创建和获取 WebGPU 设备，你需要使用 Emscripten 提供的接口来与 JavaScript 环境交互。例如，获取 navigator.gpu 和请求设备。\n示例（概念性）：\n#include \u0026lt;webgpu/webgpu.h\u0026gt; // 使用 WebGPU API // Emscripten 提供的用于与 JS 交互的宏 #include \u0026lt;emscripten/emscripten.h\u0026gt; #include \u0026lt;emscripten/html5.h\u0026gt; WGPUAdapter g_adapter = nullptr; WGPUDevice g_device = nullptr; WGPUQueue g_queue = nullptr; // C++ 函数，通过 Emscripten 暴露给 JS extern \u0026#34;C\u0026#34; EMSCRIPTEN_KEEPALIVE void init_webgpu(WGPUSurface surface_ptr) { // ... (请求 adapter, device, queue, config shader module, pipeline etc.) // 通常这一步需要异步回调，与 JS 交互 // Emscripten 提供了异步回调机制，如 emscripten_async_call 或 Promise 桥接 } // 渲染循环（通过 JS requestAnimationFrame 调用） extern \u0026#34;C\u0026#34; EMSCRIPTEN_KEEPALIVE void draw_frame() { if (!g_device) return; // ... (创建 command encoder, render pass, draw calls, submit commands) } int main() { // Emscripten_main_loop_set_timing(EM_HTML5_LOOP_RAF, 1); // 绑定到 requestAnimationFrame // 这是通常的 Emscripten 主循环设置，而不是无限循环 return 0; // Emscripten 的 main 函数返回后不会退出程序 } 你需要处理异步操作（如 requestAdapter 和 requestDevice）以及如何将 WASM 渲染循环与 requestAnimationFrame 绑定。Emscripten 提供了相应的机制。\n使用 Emscripten 编译：\nEmscripten 编译命令会有点复杂，因为它需要知道你的 WebGPU 定义，但不会链接 Dawn 库本身：\nemcc your_renderer.cpp -o your_renderer.html \\ -s USE_WEBGPU=1 \\ -s ASYNCIFY \\ -s EXPORTED_FUNCTIONS=\u0026#34;[\u0026#39;_init_webgpu\u0026#39;, \u0026#39;_draw_frame\u0026#39;]\u0026#34; \\ -s NO_EXIT_RUNTIME=1 \\ -s FORCE_FILESYSTEM=1 # 如果有文件加载 # ... 其他 Emscripten 参数 -s USE_WEBGPU=1：告诉 Emscripten，你的 C++ 代码将使用 WebGPU API，它会引入必要的 JS 胶水代码，并期望浏览器提供 WebGPU API。\n-s ASYNCIFY：如果你的 WebGPU 初始化过程包含异步操作（如 requestAdapter），你需要它来暂停 C++ 执行直到异步操作完成。\n-s EXPORTED_FUNCTIONS：暴露 C++ 函数给 JavaScript 调用。\nNO_EXIT_RUNTIME=1：防止 WASM 模块在 main() 函数结束后立即退出。\nWeb 页面 (HTML/JavaScript)：\nEmscripten 会生成一个 .html 文件和一个 .js 胶水文件，以及 .wasm 文件。\nJavaScript 会负责加载 WASM 模块，创建一个 \u0026lt;canvas\u0026gt; 元素，然后通过 Emscripten 暴露的 C++ 函数来初始化 WebGPU，并设置 requestAnimationFrame 循环来调用 WASM 中的 draw_frame 函数。\n示例 (your_renderer.js / your_renderer.html 内部的 JS):\nvar Module = { preRun: [], postRun: [], print: (function() { /* ... */ })(), printErr: (function() { /* ... */ })(), canvas: (function() { var canvas = document.getElementById(\u0026#39;canvas\u0026#39;); // Emscripten 会自动将其绑定到渲染上下文 return canvas; })(), setStatus: (function() { /* ... */ })(), totalDependencies: 0, monitorRunDependencies: function(left) { /* ... */ } }; // 异步加载 WASM 模块 Module.onRuntimeInitialized = async () =\u0026gt; { const canvas = Module.canvas; // Emscripten already binds the canvas const context = canvas.getContext(\u0026#39;webgpu\u0026#39;); // Get WebGPU context // Important: Get a WGPUSurface from the canvas context const surface = Module.WebGPUMakeSurfaceFromCanvasContext(context); // Call C++ init function, passing the surface pointer Module._init_webgpu(surface); // Assuming _init_webgpu expects a surface pointer // Setup render loop function frame() { Module._draw_frame(); requestAnimationFrame(frame); } requestAnimationFrame(frame); }; 请注意 WebGPUMakeSurfaceFromCanvasContext 是 Emscripten 在使用 USE_WEBGPU=1 时提供的一个辅助函数。\n2. 导出到本地端 (桌面应用) 在本地端，你的 C++ 程序将直接链接到 Dawn 库，并使用操作系统特定的接口（如 GLFW, SDL2, Native Windowing API）来创建窗口和管理事件。\n主要工具：C++ 编译器 (Clang, GCC, MSVC) + Dawn 库 + 窗口库\n构建 Dawn 库：\n你需要从 Dawn 的 GitHub 仓库 (https://dawn.googlesource.com/dawn 或 GitHub mirror) 克隆代码。 Dawn 使用 GN 和 Ninja 作为其构建系统。你需要按照 Dawn 仓库中的说明来构建它。这通常涉及： 安装 depot_tools (Google 的工具链管理)。 gclient sync 下载依赖。 gn gen out/Default 或 gn gen out/Debug 生成构建文件。 ninja -C out/Default 编译 Dawn。 这会生成 Dawn 的库文件（.lib, .a, .so, .dll 等取决于你的操作系统）。 编写 C++ 渲染程序：\n你的渲染代码会直接使用 Dawn 的 wgpu::Instance, wgpu::Adapter, wgpu::Device 等本地 Dawn 对象。 创建窗口：使用如 GLFW 或 SDL2 这样的库来创建 OS 窗口，并获取其 HWND (Windows), xcb_connection_t/Window (Linux X11), NSWindow (macOS) 等句柄。 通过 Dawn 的 wgpu::Instance::CreateSurface 方法，利用窗口句柄创建 wgpu::Surface。 示例（概念性）：\n#include \u0026lt;GLFW/glfw3.h\u0026gt; // 用于窗口管理 #include \u0026lt;dawn/webgpu_cpp.h\u0026gt; // 使用 Dawn 的 C++ 绑定 #include \u0026lt;dawn/native/DawnNative.h\u0026gt; // 用于 WGPUNativeInstance // 全局实例、Adapter、Device等 std::unique_ptr\u0026lt;dawn::native::Instance\u0026gt; g_instance; wgpu::Adapter g_adapter; wgpu::Device g_device; wgpu::Queue g_queue; wgpu::TextureFormat g_surfaceFormat; wgpu::Surface g_surface; void init_dawn_native(GLFWwindow* window) { g_instance = std::make_unique\u0026lt;dawn::native::Instance\u0026gt;(); g_instance-\u0026gt;DiscoverDefaultAdapters(); // 或手动选择 // 获取 SurfaceDescriptor 适配平台 #if defined(_WIN32) WGPUSurfaceDescriptorWindowsHWND surfaceDesc; surfaceDesc.chain.next = nullptr; surfaceDesc.chain.sType = WGPUSType_SurfaceDescriptorWindowsHWND; surfaceDesc.hinstance = GetModuleHandle(nullptr); surfaceDesc.hwnd = glfwGetWin32Window(window); WGPUSurfaceDescriptor sDesc; sDesc.nextInChain = reinterpret_cast\u0026lt;WGPUChainedStruct*\u0026gt;(\u0026amp;surfaceDesc); g_surface = g_instance-\u0026gt;CreateSurface(\u0026amp;sDesc); #elif defined(__APPLE__) // ... macOS specific surface creation #elif defined(__linux__) // ... Linux specific surface creation #endif // 请求 adapter 和 device // 这一步在本地通常是同步的，但在某些复杂配置下也可以异步 std::vector\u0026lt;wgpu::Adapter\u0026gt; adapters = g_instance-\u0026gt;Get Adapters(); if (adapters.empty()) return; The adapters here are wgpu::Adapter which are not exposed from the instance. adapters[0].RequestDevice(nullptr, [](WGPURequestDeviceStatus status, WGPUDevice cDevice, const char* message, void* userdata) { if (status == WGPURequestDeviceStatus_Success) { g_device = wgpu::Device::Acquire(cDevice); g_queue = g_device.GetDefaultQueue(); } else { // Error handling } }, nullptr); // ... (配置渲染管线等) } void draw_frame_native() { if (!g_device) return; // ... (创建 command encoder, render pass, draw calls, submit commands) } int main() { glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); // 禁用 OpenGL 上下文 GLFWwindow* window = glfwCreateWindow(800, 600, \u0026#34;Dawn Native\u0026#34;, nullptr, nullptr); init_dawn_native(window); // 初始化 Dawn while (!glfwWindowShouldClose(window)) { glfwPollEvents(); draw_frame_native(); // 渲染帧 } glfwDestroyWindow(window); glfwTerminate(); return 0; } 编译与链接：\n使用你的 C++ 编译器编译你的应用程序代码。 链接到你之前构建的 Dawn 库文件以及窗口库（如 GLFW）。确保编译器能找到头文件（-I）和库文件（-L）。 还需要链接到驱动程序 API（如 Vulkan, D3D12, Metal）的库，具体取决于 Dawn 的后端配置和你的目标平台。 总结与注意事项： 代码共享： 努力将核心的 WebGPU 渲染逻辑（管线创建、资源管理、绘制调用）放在一个平台无关的模块中。只有窗口创建、设备获取和主循环部分需要平台特化。 平台抽象： 可以引入一个抽象层，例如 IPlatform 接口，来处理窗口创建、事件监听和异步回调，然后针对 Web 和 Native 分别实现这个接口。 异步性： WebGPU API 本身就包含许多异步操作（requestAdapter, requestDevice, mapAsync），在 Web 端这天然是异步的，但在本地端，某些操作可能是同步或通过回调模拟异步。你需要兼容这种行为差异。 文件 I/O： 在 Web 端，直接文件 I/O 是受限的，通常需要通过 fetch API 或打包到 WASM 中；在本地端则可以自由访问文件系统。 调试： WebGPU 在浏览器中有强大的调试工具（例如 Chrome DevTools 中的 GPU 面板）。本地 Dawn 也有自己的调试层。 ","date":"2025-07-16T10:22:34+08:00","image":"https://wujilingfeng.github.io/p/web%E7%AB%AF%E6%B8%B2%E6%9F%93/img_hu_257651d1883e177a.png","permalink":"https://wujilingfeng.github.io/p/web%E7%AB%AF%E6%B8%B2%E6%9F%93/","title":"Web端渲染"},{"content":"zig语言中文社区\nzig编译为webassembly\nhttps://dev.to/sleibrock/webassembly-with-zig-part-1-4onm\nzig语言的type类型可以直接比较判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 pub fn normalize(p: anytype) Math_Compute_Abandon!void { comptime { const T=@TypeOf(p[0]); if(@TypeOf(p)!=[]T) { @compileError(\u0026#34;normalize error\\n\u0026#34;++@typeName(@TypeOf(p))++\u0026#34;fdsf\u0026#34;); } } const norm = lb_norm(p); if (approxEqAbs(@TypeOf(p[0]), norm, 0, null)) { return error.Math_Compute_Abandon; } for (p) |*pv| { pv.* /= norm; } } 下面是zig语言类型反射用法，包括访问struct类型，访问字段类型\n1 2 3 4 5 fn myget_Array_rows(comptime TT: type) usize { return @typeInfo(TT).array.len; } //下面有typeinfo的用法 pub fn mult(self: *const Self, mat: anytype) LBMatrix(T, rows, myget_Array_rows(@typeInfo(@TypeOf(mat)).@\u0026#34;struct\u0026#34;.fields[0].type)) mat的类型如下:\n1 2 3 4 5 struct { const Self = @This(); data: [rows][cols]T, } 似乎zig中的@import不能导入上层目录，也就是不能出现.. 。那也就意味着每个子文件夹里面的zig源文件都要独立成为一个自摸块，除了依赖子文件夹，不会依赖其他文件夹的zig源文件\ncomptime实战 1 2 3 4 5 6 7 8 9 10 11 12 13 14 test \u0026#34;inline while loop\u0026#34; { comptime var i = 0; // i 是一个编译期常量 var sum: usize = 0; // sum 是一个运行时变量 inline while (i \u0026lt; 3) : (i += 1) { const T = switch (i) { 0 =\u0026gt; f32, 1 =\u0026gt; i8, 2 =\u0026gt; bool, else =\u0026gt; unreachable, }; sum += typeNameLength(T); // typeNameLength 可能是一个编译期函数，用于获取类型名称的长度 } try expect(sum == 9); } 上面的例子中，如果i是不是comptime变量，就不能用inline while。\ndeepseek说只能写try comptime 而非comptime try ，可是下面的例子\n1 2 3 4 5 6 7 8 test \u0026#34;peer type resolution: ?T and T\u0026#34; { try expect(peerTypeTAndOptionalT(true, false).? == 0); try expect(peerTypeTAndOptionalT(false, false).? == 3); comptime { try expect(peerTypeTAndOptionalT(true, false).? == 0); try expect(peerTypeTAndOptionalT(false, false).? == 3); } } zig语言的切片[]T可以安全地转向[]const T ，不需要显式转换。\n下面的代码报错是因为没有确定类型导致类型推断冲突，因为x没有给类型，而-1是comptime_int,故而x是comptime_int类型，这和var冲突。\n1 2 3 4 5 6 test safe_sqrt { var x= -1;\\\\这里需改为var x:f32=-1;即可修复错误 x = x - 1; try std.testing.expect(safe_sqrt(x) \u0026gt;= 0); } 一般来说zig语言的绑定库只需要@cImport()该库的暴露的.h文件即可，但是有些时候会再在上面裹上一层zig的wrapper， 比如这个mach-glfw 里面的main分支，就是@cImport()之后又裹了一层zig。\n如果zig语言想要实现类型类，只需要写个满足类型类约束的comptime函数，也就是在编译期进行类型检查是否有某些方法的判断，然后在需要添加类型类约束的函数上添加这个编译期函数判断即可。\n编译系统 下面是编译c语言项目的构建代码，有冗余，这里的注释部分也能添加源文件，到底是cstructures_mod还是cstructures添加源文件呢？写法不统一。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const cstructures_mod = b.addModule(\u0026#34;cstructures_mod\u0026#34;, .{ .target = target, .optimize = optimize, .root_source_file = null, }); // cstructures_mod.addIncludePath(b.path(\u0026#34;cstructures/include\u0026#34;)); // cstructures_mod.addCSourceFiles(.{ // .files = \u0026amp;.{\u0026#34;cstructures/src/tools_node.c\u0026#34;}, // .flags = \u0026amp;.{ \u0026#34;-Wall\u0026#34;, \u0026#34;-O2\u0026#34; }, // }); const cstructures = b.addLibrary(.{ .linkage = .static, .name = \u0026#34;cstructures\u0026#34;, .root_module = cstructures_mod, }); cstructures.addIncludePath(b.path(\u0026#34;cstructures/include\u0026#34;)); cstructures.addCSourceFiles(.{ .files = \u0026amp;.{\u0026#34;cstructures/src/tools_node.c\u0026#34;}, .flags = \u0026amp;.{ \u0026#34;-Wall\u0026#34;, \u0026#34;-O2\u0026#34; }, }); cstructures.linkLibC(); 导出为webassembly 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.Build) void { const target = b.resolveTargetQuery(std.Target.Query.parse( .{ .arch_os_abi = \u0026#34;wasm32-wasi\u0026#34; }, ) catch unreachable); const exe = b.addExecutable(.{ .name = \u0026#34;main\u0026#34;, .root_source_file = b.path(\u0026#34;src/main.zig\u0026#34;), .target = target, .optimize = b.standardOptimizeOption(.{}), }); //注意这个选项 exe.rdynamic = true; //导出该可执行对象中标记了export的项目 // 此项默认为false，如果你需要在js环境中调用导出的方法，需要设置为true b.installArtifact(exe); //保存生成的结果 } 下面是ai生成测试用例\n编写 Zig 代码举例 以最小 Hello World 为例：\n// main.zig const std = @import(\u0026#34;std\u0026#34;); export fn add(a: i32, b: i32) i32 { return a + b; } 说明:\nexport 标记表明该函数将被导出到 WASM 模块，从 JS 里可调用。 编写 build.zig build.zig 是使用 Zig 提供构建脚本功能的新式方法。下面以导出 WASM 的例子说明：\nconst std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.Build) void { const target = b.standardTargetOptions(.{ .default_target = .{ .arch = .wasm32, .os_tag = .freestanding } }); const optimize = b.standardOptimizeOption(.{}); const exe = b.addExecutable(.{ .name = \u0026#34;zighello\u0026#34;, .root_source_file = .{ .path = \u0026#34;main.zig\u0026#34; }, .target = target, .optimize = optimize, }); // 控制输出为 WebAssembly (wasm) exe.setOutputFile(\u0026#34;zighello.wasm\u0026#34;); // 一般来说，Web 上不需要标准库 exe.stack_size = 64 * 1024; // 可选: 设置栈大小 exe.disable_stack_protector = true; // 可选: 关闭栈保护 b.default_step.dependOn(\u0026amp;exe.step); } 参数说明:\ntarget 选用了 .wasm32 和 .freestanding (面向浏览器用freestanding。若需要标准库，如文件io，则用 .wasm32-wasi) addExecutable 制作出可执行 WASM, 并命名和指向源代码 .setOutputFile 明确指定输出文件名 default_step.dependOn 确保执行默认构建流程 编译命令 在含有 build.zig 的目录下运行：\nsh zig build 正常情况下会输出 zighello.wasm 文件。\n用 JavaScript 加载 WASM 最基础的 JS 加载代码如下：\njsfetch(\u0026#39;zighello.wasm\u0026#39;) .then(response =\u0026gt; response.arrayBuffer()) .then(bytes =\u0026gt; WebAssembly.instantiate(bytes)) .then(results =\u0026gt; { // zighello.wasm 里由 zig export 的函数 const add = results.instance.exports.add; console.log(\u0026#39;zig add:\u0026#39;, add(33, 44)); // 输出 77 }); 注意事项\n用 wasm32-freestanding 方式 Zig 标准库很多功能不可用（如I/O） 若常用 Zig 标准库（如console打印、文件IO），应将目标置为 wasm32-wasi，并在 Node/服务器侧WASI环境执行 进阶提示 与 JS 更复杂的数据交互 WASM 只支持数字（int、float\u0026hellip;），字符串等需传递内存指针。 编译到 wasm32-wasi 可在 build.zig 里改为 .os_tag = .wasi，能用 std.io、环境变量等 自动产出 JS 绑定代码 可用 Zig 社区 wasm-bindings 或仅用 JS Fetch 加载 WebAssembly 与 Zig 版本 推荐使用最新 Zig 版本（如0.12.0及以上）以获得更好的 WASM 支持 参考更复杂的实际 build.zig 示例 适配多种目标，暴露参数给命令行：\nconst std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.Build) void { const target = b.standardTargetOptions(.{}); const optimize = b.standardOptimizeOption(.{}); const exe = b.addExecutable(.{ .name = \u0026#34;demo\u0026#34;, .root_source_file = .{ .path = \u0026#34;src/main.zig\u0026#34; }, .target = target, .optimize = optimize, }); exe.setOutputDir(\u0026#34;dist\u0026#34;); // 输出到dist文件夹 exe.setOutputFile(\u0026#34;demo.wasm\u0026#34;); b.installArtifact(exe); // 默认步骤 b.default_step.dependOn(\u0026amp;exe.step); } 常见问题 Q: 为什么JS调用WASM时找不到导出函数？ A: 需用 export fn ...，如果没用export明示导出，WASM模块不会暴露该函数。 Q: Zig标准库不能用/编译时报错？ A: wasmf32-freestanding下禁用 std，换用wasm32-wasi作为target 或手工实现基础IO。 Q: 如何编译为Emscripten兼容的WASM？ A: 目前Zig不直接输出专为Emscripten定制代码。需自己对接JS glue code。 生成文档 zig生成的文档，首先安装bun，然后在文档目录下执行命令bunx serve .。这是因为main.js里面需要借助http获取wasm，所以直接打开index.html没用。\n","date":"2025-06-20T10:36:14+08:00","image":"https://wujilingfeng.github.io/p/zig%E5%AE%9E%E6%88%98/nature_hu_e18e38c523eb116e.png","permalink":"https://wujilingfeng.github.io/p/zig%E5%AE%9E%E6%88%98/","title":"Zig实战"},{"content":"gltf文件格式介绍\ngltf文件格式\n","date":"2025-05-19T18:05:13+08:00","image":"https://wujilingfeng.github.io/p/gltf%E6%A0%BC%E5%BC%8F/jiari_hu_ac2d69a4c5121dcc.png","permalink":"https://wujilingfeng.github.io/p/gltf%E6%A0%BC%E5%BC%8F/","title":"Gltf格式"},{"content":"按照网址进行配置.\n对于zorin os等基于ubuntu的发行版本，需要修改sudo vim /etc/os-release , 把ID设置为ubuntu。\n1 2 3 sudo apt update wget https://repo.radeon.com/amdgpu-install/6.3.4/ubuntu/jammy/amdgpu-install_6.3.60304-1_all.deb sudo apt install ./amdgpu-install_6.3.60304-1_all.deb 然后运行\n1 amdgpu-install -y --usecase=graphics,rocm 这个网址告诉如何在ubuntu的仓库安装rocm\n","date":"2025-05-13T17:46:40+08:00","image":"https://wujilingfeng.github.io/p/minkowski%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/rain_hu_5b8a3ec5d31f3dc8.png","permalink":"https://wujilingfeng.github.io/p/minkowski%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/","title":"Minkowski框架学习"},{"content":"","date":"2025-04-30T16:52:46+08:00","image":"https://wujilingfeng.github.io/p/futhark%E5%AD%A6%E4%B9%A0/jinshan_hu_da357d4670659311.png","permalink":"https://wujilingfeng.github.io/p/futhark%E5%AD%A6%E4%B9%A0/","title":"Futhark学习"},{"content":"Parallel and Concurrent Programming in Haskell[Book]\n","date":"2025-04-29T10:58:01+08:00","image":"https://wujilingfeng.github.io/p/haskell%E5%AD%A6%E4%B9%A0/img_hu_1b7eaa217e0b240d.png","permalink":"https://wujilingfeng.github.io/p/haskell%E5%AD%A6%E4%B9%A0/","title":"Haskell学习"},{"content":"hugo 似乎的确存在很多bug。\nstack主题对于baseurl的路径处理有bug，例如当baseurl = https://wujilingfeng.github.io/myblog/时，生成的网页内容路径会自动添加myblog。\nstack主题对于文章的语言分类是以md的文件名中缀zh-cn,en,ar来进行区分的。\n","date":"2025-04-29T08:57:27+08:00","image":"https://wujilingfeng.github.io/p/hugo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/shumu_hu_dc6f308cae3ae0e5.png","permalink":"https://wujilingfeng.github.io/p/hugo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","title":"Hugo+github搭建博客"},{"content":"zig语言每个变量分为const 和var，结构体成员变量（除了静态变量）的const和var是和该结构体实例相同。\nzig语言对函数声明和定义启用延迟检查分析，也就是如果定义的函数未使用，zig编译器就不会分析检查该函数，也就更不会对该函数报错。\nzig语言的void和c语言的void不同，c语言的void对应anyopaque，是对opaque的泛化，就像anytype是对type的泛化，anyerror对error的泛化。void也是一个类型，它的值通常为{}。\nzig语言 的”元组“，.{\u0026ldquo;nihao\u0026rdquo;,3}其实是个value, 它的类型是匿名结构体，\nzig语言会自动对结构体的内存进行布局优化，下面的例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const RB_Node = struct { key: i32, left: ?*RB_Node, right: ?*RB_Node, parent: ?*RB_Node, color: bool, }; dprint(\u0026#34;rb node size:{}\\n\u0026#34;, .{@sizeOf(RB_Node)}); std.debug.print(\u0026#34;Size of RB_Node: {}\\n\u0026#34;, .{@sizeOf(RB_Node)}); std.debug.print(\u0026#34;Offset of key: {}\\n\u0026#34;, .{@offsetOf(RB_Node, \u0026#34;key\u0026#34;)}); std.debug.print(\u0026#34;Offset of left: {}\\n\u0026#34;, .{@offsetOf(RB_Node, \u0026#34;left\u0026#34;)}); std.debug.print(\u0026#34;Offset of right: {}\\n\u0026#34;, .{@offsetOf(RB_Node, \u0026#34;right\u0026#34;)}); std.debug.print(\u0026#34;Offset of parent: {}\\n\u0026#34;, .{@offsetOf(RB_Node, \u0026#34;parent\u0026#34;)}); std.debug.print(\u0026#34;Offset of color: {}\\n\u0026#34;, .{@offsetOf(RB_Node, \u0026#34;color\u0026#34;)}); zig语言的anytype只用于函数的参数声明（其他都不能用，函数的返回类型也不能用anytype,似乎zig内置函数可以）。\nzig 的test的函数必须是字符串，否则必须是标识符，一般和某个函数名的标识符相同，这样会作为该函数的文档测试说明。test函数的默认返回类型是错误联合类型，也就是!void\n这个网页说明了一些用法\n错误处理 zig语言的error类型会自动赋一个整数值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const FileOpenError = error{ AccessDenied, OutOfMemory, FileNotFound, }; const AllocationError = error{ OutOfMemory, }; pub fn main() !void { const errort = FileOpenError.OutOfMemory; const err_int = @intFromError(errort); const err_int1 = @intFromError(AllocationError.OutOfMemory); dprint(\u0026#34;value errot:{},{}\\n\u0026#34;, .{ err_int, err_int1 }); } zig语言的catch是个二元运算符,value = expression catch default_value;，含义：\n如果 expression 成功（返回 T 类型的值），则 value 被赋值为该值。 如果 expression 返回错误（error 类型），则 value 被赋值为 default_value。 如:\n1 const number = parseU64(str, 10) catch 13; 在 Zig 中，catch 还支持一种扩展形式，允许你在捕获错误时执行自定义逻辑。这种用法的语法是：\n1 2 value = expression catch |err| { /* handle error */ }; expression catch |err| return err;这个语句完全等价try。 错误联合类型可以用if语句解包，但必须包含else分支，否则报错，也可以用while解包，但也需要包含else分支，否则报错。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const a: anyerror!u32 = error.AlwaysError; if (a) |value| { std.debug.print(\u0026#34;type a{}\\n\u0026#34;, .{value}); // 处理正常值 } else |err| { std.debug.print(\u0026#34;type a{}\\n\u0026#34;, .{err}); // 处理错误（必须显式捕获err） } fn fetchData() anyerror!u32 { // 模拟可能失败的操作 return if (std.crypto.random.int(u32) % 2 == 0) 42 else error.FetchFailed; } pub fn main() void { var retry: u32 = 0; while (fetchData()) |data| { std.debug.print(\u0026#34;Data: {}\\n\u0026#34;, .{data}); retry += 1; if (retry \u0026gt;= 3) break; // 防止无限循环 } else |err| { std.debug.print(\u0026#34;Error: {}\\n\u0026#34;, .{err}); } } 上面的||捕获可以是|_|，即忽略捕获值。 可选联合类型 zig语言的orelse也是二元运算符，用来解包可选类型，左右两边两个表达式为执行代码，const b= a orelse value其中a是可选类型，b的值是当a不为null时，b为a的解包值，否则b为value。也可以用.?可访问非null的值（如果是null会引发panic）,if(optional_value)|value|是最安全的用法，while也可以解包可选类型。\nzig语言的return,break,continue,unreachable，while(true){}属于noreturn类型的值，用法基本和c一样，return用于全局退出，break用于局部退出。所以标签块要用break退出.\nzig语言的noreturn 可以和任何类型兼容，所以任何表达式都可以使用noreturn赋值，但因为是noreturn 类型，赋值操作不会执行，只会影响控制。\n下面是标签块的使用，\n1 2 3 4 5 6 var y: i32 = 123; const x = blk: { y += 1; break :blk y; }; 标记联合体 下面的@typeInfo返回的Type类型就是个union(enum)\n1 2 3 4 5 6 7 8 9 10 11 12 /// Checks if a `Ptr` is a pointer to `Item`. /// Note that the pointer is allowed to have the `const`, `volatile` or `allowzero` keyword. pub fn isSizeOnePoiner( comptime Item: type, comptime Ptr: type, ) bool { return switch (@typeInfo(Ptr)) { .pointer =\u0026gt; |p| p.size == .one and p.child == Item, else =\u0026gt; false, }; } 下面展示了枚举变量的简洁写法，\n1 2 3 4 5 const Color = enum { red, @\u0026#34;really red\u0026#34;, }; const color: Color = .@\u0026#34;really red\u0026#34;; 容器级别变量具有静态生命周期，且顺序无关，并且是惰性分析的。容器级别变量的初始化值隐式为编译时。如果容器级别变量是const，则其值在编译时已知，否则是在运行时已知。\n1 2 3 4 5 6 7 8 9 10 11 var y:i32=add(10,x); const x: i32=add(12,34); test \u0026#34;container level variables\u0026#34;{ try expect(x==46); try expect(y==56); } fn add(a:i32,b:i32) i32{ return a+b; } const std= @import(\u0026#34;std\u0026#34;) const expect= std.testing.expect; zig语言的const变量尽量会在编译器赋值或者初始化，尤其是在容器内的const变量只会在编译时赋值。\n如果想让var变量的初始化也在编译时进行，可以\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 test \u0026#34;comptime vars\u0026#34; { var x: i32 = 1; comptime var y: i32 = 1; x += 1; y += 1; try expect(x == 2); try expect(y == 2); if (y != 2) { // This compile error never triggers because y is a comptime variable, // and so `y != 2` is a comptime value, and this if is statically evaluated. @compileError(\u0026#34;wrong y value\u0026#34;); } } zig语言的切片和数组（array）的区别似乎只是固定长度和动态长度的区别。而且数组不能转化为指针和切片，只有数组的指针才能转化为切片和指向多个元素的指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const all_zero = [_]u16{0} ** 10; const Point = struct { x: i32, y: i32, }; test \u0026#34;compile-time array initialization\u0026#34; { try expect(fancy_array[4].x == 4); try expect(fancy_array[4].y == 8); } // call a function to initialize an array var more_points = [_]Point{makePoint(3)} ** 10; fn makePoint(x: i32) Point { return Point{ .x = x, .y = x * 2, }; } zig语言数组的初始化用法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const all_zero = [_]u16{0} ** 10; comptime { assert(all_zero.len == 10); assert(all_zero[5] == 0); } const Point = struct { x: i32, y: i32, }; test \u0026#34;compile-time array initialization\u0026#34; { try expect(fancy_array[4].x == 4); try expect(fancy_array[4].y == 8); } // call a function to initialize an array var more_points = [_]Point{makePoint(3)} ** 10; fn makePoint(x: i32) Point { return Point{ .x = x, .y = x * 2, }; } 虽然数组和切片更相似，但是切片和数组指针存在默认转换,数组的指针可以默认转化为切片，反之不行(除非在编译阶段能确定切片长度，这样就可以把切片默认转化为数组指针)。数组指针也可以转化为多项指针。\n1 2 3 4 5 6 7 8 9 10 11 const bytes: *const [5:0]u8 = \u0026#34;hello\u0026#34;; dprint(\u0026#34;bytes type:{}\\n\u0026#34;, .{@TypeOf(bytes)}); // const slice: []const u8 = \u0026#34;slice\u0026#34;; const slice: []const u8 = bytes;\\\\数组的指针转化为切片 dprint(\u0026#34;slice type:{}\\n\u0026#34;, .{@TypeOf(slice)}); const array: [5]u8 = [5]u8{ 1, 2, 3, 4, 5 }; const array_ptr = \u0026amp;array; dprint(\u0026#34;array type:{}\\n\u0026#34;, .{@TypeOf(array_ptr)}); const array_ptr1: [*]const u8 = \u0026amp;array;\\\\数组的指针转化为指向多个元素的指针。 dprint(\u0026#34;array type1:{}\\n\u0026#34;, .{@TypeOf(array_ptr1)}); 单个的指针ptr可以通过ptr[0..1]转化为切片（但是会在编译阶段优化为数组的指针）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 var sum2: i32 = 0; for (items, 0..) |_, i| { try expect(@TypeOf(i) == usize); sum2 += @as(i32, @intCast(i)); } test \u0026#34;switch simple\u0026#34; { const a: u64 = 10; const zz: u64 = 103; // All branches of a switch expression must be able to be coerced to a // common type. // // Branches cannot fallthrough. If fallthrough behavior is desired, combine // the cases and use an if. const b = switch (a) { // Multiple cases can be combined via a \u0026#39;,\u0026#39; 1, 2, 3 =\u0026gt; 0, // Ranges can be specified using the ... syntax. These are inclusive // of both ends. 5...100 =\u0026gt; 1, // Branches can be arbitrarily complex. 101 =\u0026gt; blk: { const c: u64 = 5; break :blk c * 2 + 1; }, // Switching on arbitrary expressions is allowed as long as the // expression is known at compile-time. zz =\u0026gt; zz, blk: { const d: u32 = 5; const e: u32 = 100; break :blk d + e; } =\u0026gt; 107, // The else branch catches everything not already captured. // Else branches are mandatory unless the entire range of values // is handled. else =\u0026gt; 9, }; try expect(b == 1); } 在 switch 中，范围使用了三个点，即 3...6，而这个示例中，范围使用了两个点，即 0..10。这是因为在 switch 中，范围的两端都是闭区间，而 for 则是左闭右开。\nzig语言的函数参数默认是const，即不能修改参数的值。\n逻辑流程控制 下面是while的用法，支持一个额外的每次运行的表达式。\n1 2 3 4 5 6 7 8 9 10 11 test \u0026#34;while loop continue expression, more complicated\u0026#34; { var i: usize = 1; var j: usize = 1; while (i * j \u0026lt; 2000) : ({ i *= 2; j *= 3; }) { const my_ij = i * j; try expect(my_ij \u0026lt; 2000); } } 其实while也是个表达式，它的值既可以是while循环里break value返回的value，也可以是else表达式返回的值.\n1 2 3 4 5 6 7 8 fn rangeHasNumber(begin: usize, end: usize, number: usize) bool { var i = begin; return while (i \u0026lt; end) : (i += 1) { if (i == number) { break true; } } else false; } 1 2 3 4 5 6 7 8 9 10 11 fn myfun()!void{ var buf: [30]u8 = undefined; //在这里try语句遇到错误会从终止函数并返回错误结果，因为stdin.readUntilDelimiterOrEof(\u0026amp;buf, \u0026#39;\\n\u0026#39;)的返回值类型为`!?[]u8`，所以 //if语句解包的是可选类型，得到|line| if (try stdin.readUntilDelimiterOrEof(\u0026amp;buf, \u0026#39;\\n\u0026#39;)) |line| { } } if else语句也可以当作表达式，如下:\n1 2 3 4 5 6 7 8 9 10 11 pub fn addpolynomials(self: *Self, p1: []T, p2: []T, result: ?[]T) ?[]T { const maxDegree = if (p1.len \u0026gt; p2.len) p1.len else p2.len; const re = if (result) |re1| if (re1.len \u0026lt; maxDegree) return null else re1 else self.allocator.alloc(T, maxDegree) catch return null; for (0..maxDegree) |i| { re[i] = (if (i \u0026lt; p1.len) p1[i] else 0) + (if (i \u0026lt; p2.len) p2[i] else 0); } return re; } 在函数的泛型参数中anytype和comptime T:type，在效率上似乎是一样的，comptime T更清晰但是接口更复杂，anytype接口简洁但是需要推导类型（@TypeOf）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const std = @import(\u0026#34;std\u0026#34;); const expect = std.testing.expect; const ComplexTypeTag = enum { ok, not_ok, }; const ComplexType = union(ComplexTypeTag) { ok: u8, not_ok: void, }; test \u0026#34;modify tagged union in switch\u0026#34; { var c = ComplexType{ .ok = 42 }; switch (c) { ComplexTypeTag.ok =\u0026gt; |*value| value.* += 1, ComplexTypeTag.not_ok =\u0026gt; unreachable, } try expect(c.ok == 43); } defer是在作用域退出时执行表达式，表达式当然可以是块（block）。defer , if , while,for ,switch关键字都是控制语句，后面如果是单个语句要加;, 如果是{}不加分号。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 onst std = @import(\u0026#34;std\u0026#34;); const expect = std.testing.expect; const print = std.debug.print; fn deferExample() !usize { var a: usize = 1; { defer a = 2; a = 1; } try expect(a == 2); a = 5; return a; } test \u0026#34;defer basics\u0026#34; { try expect((try deferExample()) == 5); } 内存分配器 std.testing.allocator是建议且只建议在test函数中使用的内存分配器。\n1 2 3 4 5 6 7 test \u0026#34;detect leak\u0026#34; { var list = std.ArrayList(u21).init(std.testing.allocator); // missing `defer list.deinit();` try list.append(\u0026#39;☔\u0026#39;); try std.testing.expect(list.items.len == 1); } 数值 在 Zig 语言中，‌低精度数值向高精度变量赋值时不需要显式转换，编译器会自动完成安全的隐式提升‌。\n在Zig语言中，‌高精度数值赋给低精度变量需要显式转换‌，否则会触发编译错误。@intCast、@truncate、@floatCast\nZig 模块导入核心规则 路径导入继承依赖：使用 @import(\u0026quot;./file.zig\u0026quot;) 导入文件时，该文件会自动继承父模块（即调用 @import 的模块）通过 addImport 添加的所有命名模块。这意味着，只要在 exe.root_module 中添加了依赖（如 addImport(\u0026quot;tracy\u0026quot;, tracy_mod)），所有通过路径导入的 .zig 文件都能直接使用 @import(\u0026quot;tracy\u0026quot;)。\n命名导入不传递依赖：通过 A.addImport(\u0026quot;B\u0026quot;, B_mod) 仅允许模块 A 访问 B。模块 B 不会自动继承 A 的其他依赖，依赖关系是单向的。若 B 也需要使用其他模块，必须显式为其添加 addImport。\n✅ 实践建议：在 build.zig 中，只需为 exe.root_module 添加一次 addImport，项目内所有通过相对路径导入的 .zig 文件即可共享这些依赖，无需为每个文件单独创建模块。这是构建大型项目的关键模式。\n额外说明 经过测试，结构体内部的函数和成员变量不能重名，block的标签名可以重名（除了嵌套）。\nzig的import导入模块的话，如果是直接@import 文件名的话，相对路径是相对于该导入文件的路径。\nzig的defer后面语句只能是void,也就是函数或者块不能返回值。\n风格指南\n请注意，下面的代码中a不是二维数组，它是一维数组，每个分量是切片。同理window_name是一维数组，由于切片，数组指针，指向多项的指针三者存在默认转换关系，所以window_name的每个分量是个指向多项的数组。\n1 2 const a=[_][]const u8{ \u0026#34;src\u0026#34;, \u0026#34;test\u0026#34;, \u0026#34;example\u0026#34; } const window_name = [1][*:0]const u8{\u0026#34;window name\u0026#34;}; zig语言的构建系统 zig语言的build.zig中，每个module或者test的root_source_file只能指向一个.zig文件（必须是相对路径），不可以是路径。\n示例：\n1 2 3 exe.addModule(\u0026#34;my_module\u0026#34;, .{ .root_source_file = .{ .path = \u0026#34;src/my_module\u0026#34; }, // 这里是目录 }); 然后在你的代码里可以这样用：\n1 2 const foo = @import(\u0026#34;my_module/foo.zig\u0026#34;); const bar = @import(\u0026#34;my_module/bar.zig\u0026#34;); 1. addModule 作用：创建一个模块，并将其添加到当前包的模块集合（b.modules）。\n可见性：公开（public）。这个模块会被暴露给依赖当前包的其他包（即作为 package 的“导出模块”）。\n典型用途：当你希望你的库/包对外暴露一个或多个模块时，使用 addModule。\n调用方式：\n1 const my_mod = b.addModule(\u0026#34;my_mod\u0026#34;, .{ .root_source_file = ... }); 效果：其他包可以通过 @import(\u0026quot;my_mod\u0026quot;) 访问这个模块。\n2. createModule 作用：创建一个模块，但不添加到包的模块集合，仅供当前包内部使用。 可见性：私有（private）。这个模块不会被暴露给依赖当前包的其他包。 典型用途：当你只需要在当前包内部组织代码、复用代码，但不希望对外暴露时，使用 createModule。 调用方式： 1 const my_private_mod = b.createModule(.{ .root_source_file = ... }); 效果：只能在当前包的 build 脚本中通过 addImport 等方式引用，外部包无法通过 @import 访问。 总结对比表 函数名 是否加入 b.modules 是否对外暴露 用途 addModule 是 是 对外暴露的模块 createModule 否 否 仅包内私有的模块 zig的编译系统中每个addTest和addExecutable都独立存在，哪怕它们指向同一个root_source_file，也就是有时多个文件内容test函数会多次运行。\nzig fetch zig fetch --save \u0026quot;git+https://github.com/用户/仓库.git#\u0026lt;commit_hash或者tag\u0026gt;\u0026quot;\n如果省掉#\u0026lt;commit_hash或者tag\u0026gt;就会拉取默认分支的最新的提交\n1 zig fetch --save=glfw \u0026#34;git+https://github.com/glfw/glfw.git\u0026#34; 下面测试也是可以的，但是不稳定，因为分支会变动\n1 zig fetch --save https://github.com/webui-dev/zig-webui/archive/main.tar.gz 如果自己手动填写url时，格式为\nhttps://github.com/\u0026lt;用户名\u0026gt;/\u0026lt;仓库名\u0026gt;/archive/\u0026lt;commit或tag\u0026gt;.tar.gz\n可以在build.zig中添加传递参数\n1 2 3 4 const exe = b.addExecutable(...); if (b.args) |args| { exe.addArgs(args); // 将构建参数传递给可执行文件 } 然后在程序中使用参数\n1 2 3 4 5 6 7 8 9 10 pub fn main() !void { const args = try std.process.argsAlloc(std.heap.page_allocator); defer std.process.argsFree(std.heap.page_allocator, args); // args[0]是程序名，args[1..]才是实际参数 for (args[1..]) |arg| { std.debug.print(\u0026#34;参数: {s}\\n\u0026#34;, .{arg}); } } 和外部（比如C）交互 1 2 3 4 5 6 7 8 9 10 const cstdio = @cImport({ // See https://github.com/ziglang/zig/issues/515 @cDefine(\u0026#34;_NO_CRT_STDIO_INLINE\u0026#34;, \u0026#34;1\u0026#34;); @cInclude(\u0026#34;stdio.h\u0026#34;); }); pub fn main() void{ _ = cstdio.printf(\u0026#34;hello\\n\u0026#34;); } 上面展示了引入c头文件的功能，需要在编译文件build.zig中添加exe.linkLibC();\nextern关键字表示在链接时才确定的符号，一般用在zig调用外部符号\n1 2 3 4 5 6 // extern声明用于声明将在链接时、静态链接时或运行时动态链接的函数。 // extern 关键字后的引号标识符指定具有该函数的库。（例如，“c”-\u0026gt;libc.so） // callconv 标记更改了函数的调用约定。 const WINAPI: std.builtin.CallingConvention = if (native_arch == .x86) .Stdcall else .C; extern \u0026#34;kernel32\u0026#34; fn ExitProcess(exit_code: u32) callconv(WINAPI) noreturn; extern \u0026#34;c\u0026#34; fn atan2(a: f64, b: f64) f64; ","date":"2025-04-28T00:00:00Z","image":"https://wujilingfeng.github.io/p/%E5%AD%A6%E4%B9%A0zig/fanchuan_hu_de82c3423caf9845.png","permalink":"https://wujilingfeng.github.io/p/%E5%AD%A6%E4%B9%A0zig/","title":"学习zig"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://wujilingfeng.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash.zh-cn_hu_2307260c751d0e0b.jpg","permalink":"https://wujilingfeng.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://wujilingfeng.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://wujilingfeng.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://wujilingfeng.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://wujilingfeng.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://wujilingfeng.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://wujilingfeng.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://wujilingfeng.github.io/p/emoji-support/","title":"Emoji Support"}]