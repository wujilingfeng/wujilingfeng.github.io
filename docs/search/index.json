[{"content":"zig语言中文社区\nzig编译为webassembly\n一般来说zig语言的绑定库只需要@cImport()该库的暴露的.h文件即可，但是有些时候会再在上面裹上一层zig的wrapper， 比如这个mach-glfw 里面的main分支，就是@cImport()之后又裹了一层zig。\n如果zig语言想要实现类型类，只需要写个满足类型类约束的comptime函数，也就是在编译期进行类型检查是否有某些方法的判断，然后在需要添加类型类约束的函数上添加这个编译期函数判断即可。\n编译系统 下面是编译c语言项目的构建代码，有冗余，这里的注释部分也能添加源文件，到底是cstructures_mod还是cstructures添加源文件呢？写法不统一。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const cstructures_mod = b.addModule(\u0026#34;cstructures_mod\u0026#34;, .{ .target = target, .optimize = optimize, .root_source_file = null, }); // cstructures_mod.addIncludePath(b.path(\u0026#34;cstructures/include\u0026#34;)); // cstructures_mod.addCSourceFiles(.{ // .files = \u0026amp;.{\u0026#34;cstructures/src/tools_node.c\u0026#34;}, // .flags = \u0026amp;.{ \u0026#34;-Wall\u0026#34;, \u0026#34;-O2\u0026#34; }, // }); const cstructures = b.addLibrary(.{ .linkage = .static, .name = \u0026#34;cstructures\u0026#34;, .root_module = cstructures_mod, }); cstructures.addIncludePath(b.path(\u0026#34;cstructures/include\u0026#34;)); cstructures.addCSourceFiles(.{ .files = \u0026amp;.{\u0026#34;cstructures/src/tools_node.c\u0026#34;}, .flags = \u0026amp;.{ \u0026#34;-Wall\u0026#34;, \u0026#34;-O2\u0026#34; }, }); cstructures.linkLibC(); 导出为webassembly 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.Build) void { const target = b.resolveTargetQuery(std.Target.Query.parse( .{ .arch_os_abi = \u0026#34;wasm32-wasi\u0026#34; }, ) catch unreachable); const exe = b.addExecutable(.{ .name = \u0026#34;main\u0026#34;, .root_source_file = b.path(\u0026#34;src/main.zig\u0026#34;), .target = target, .optimize = b.standardOptimizeOption(.{}), }); //注意这个选项 exe.rdynamic = true; //导出该可执行对象中标记了export的项目 // 此项默认为false，如果你需要在js环境中调用导出的方法，需要设置为true b.installArtifact(exe); //保存生成的结果 } ","date":"2025-06-20T10:36:14+08:00","image":"https://wujilingfeng.github.io/p/zig%E5%AE%9E%E6%88%98/nature_hu_e18e38c523eb116e.png","permalink":"https://wujilingfeng.github.io/p/zig%E5%AE%9E%E6%88%98/","title":"Zig实战"},{"content":"gltf文件格式介绍\ngltf文件格式\n","date":"2025-05-19T18:05:13+08:00","image":"https://wujilingfeng.github.io/p/gltf%E6%A0%BC%E5%BC%8F/jiari_hu_ac2d69a4c5121dcc.png","permalink":"https://wujilingfeng.github.io/p/gltf%E6%A0%BC%E5%BC%8F/","title":"Gltf格式"},{"content":"按照网址进行配置.\n对于zorin os等基于ubuntu的发行版本，需要修改sudo vim /etc/os-release , 把ID设置为ubuntu。\n1 2 3 sudo apt update wget https://repo.radeon.com/amdgpu-install/6.3.4/ubuntu/jammy/amdgpu-install_6.3.60304-1_all.deb sudo apt install ./amdgpu-install_6.3.60304-1_all.deb 然后运行\n1 amdgpu-install -y --usecase=graphics,rocm 这个网址告诉如何在ubuntu的仓库安装rocm\n","date":"2025-05-13T17:46:40+08:00","image":"https://wujilingfeng.github.io/p/minkowski%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/rain_hu_5b8a3ec5d31f3dc8.png","permalink":"https://wujilingfeng.github.io/p/minkowski%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/","title":"Minkowski框架学习"},{"content":"","date":"2025-04-30T16:52:46+08:00","image":"https://wujilingfeng.github.io/p/futhark%E5%AD%A6%E4%B9%A0/jinshan_hu_da357d4670659311.png","permalink":"https://wujilingfeng.github.io/p/futhark%E5%AD%A6%E4%B9%A0/","title":"Futhark学习"},{"content":"Parallel and Concurrent Programming in Haskell[Book]\n","date":"2025-04-29T10:58:01+08:00","image":"https://wujilingfeng.github.io/p/haskell%E5%AD%A6%E4%B9%A0/img_hu_1b7eaa217e0b240d.png","permalink":"https://wujilingfeng.github.io/p/haskell%E5%AD%A6%E4%B9%A0/","title":"Haskell学习"},{"content":"hugo 似乎的确存在很多bug。\nstack主题对于baseurl的路径处理有bug，例如当baseurl = https://wujilingfeng.github.io/myblog/时，生成的网页内容路径会自动添加myblog。\nstack主题对于文章的语言分类是以md的文件名中缀zh-cn,en,ar来进行区分的。\n","date":"2025-04-29T08:57:27+08:00","image":"https://wujilingfeng.github.io/p/hugo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/shumu_hu_dc6f308cae3ae0e5.png","permalink":"https://wujilingfeng.github.io/p/hugo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","title":"Hugo+github搭建博客"},{"content":"zig语言每个变量分为const 和var，结构体成员变量（除了静态变量）的const和var是和该结构体实例相同。\nzig语言对函数声明和定义启用延迟检查分析，也就是如果定义的函数未使用，zig编译器就不会分析检查该函数，也就更不会对该函数报错。\nzig语言的void和c语言的void不同，c语言的void对应anyopaque,anyopaque是一个类型，而anytype是一个关键词，类似struct ,enum,fn,if, else等。void也是一个类型，它的值通常为{}。anyerror 是一个类型，不是关键字。\nzig语言 的”元组“，.{\u0026ldquo;nihao\u0026rdquo;,3}其实是个value, 它的类型是匿名结构体，\nzig语言会自动对结构体的内存进行布局优化，下面的例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const RB_Node = struct { key: i32, left: ?*RB_Node, right: ?*RB_Node, parent: ?*RB_Node, color: bool, }; dprint(\u0026#34;rb node size:{}\\n\u0026#34;, .{@sizeOf(RB_Node)}); std.debug.print(\u0026#34;Size of RB_Node: {}\\n\u0026#34;, .{@sizeOf(RB_Node)}); std.debug.print(\u0026#34;Offset of key: {}\\n\u0026#34;, .{@offsetOf(RB_Node, \u0026#34;key\u0026#34;)}); std.debug.print(\u0026#34;Offset of left: {}\\n\u0026#34;, .{@offsetOf(RB_Node, \u0026#34;left\u0026#34;)}); std.debug.print(\u0026#34;Offset of right: {}\\n\u0026#34;, .{@offsetOf(RB_Node, \u0026#34;right\u0026#34;)}); std.debug.print(\u0026#34;Offset of parent: {}\\n\u0026#34;, .{@offsetOf(RB_Node, \u0026#34;parent\u0026#34;)}); std.debug.print(\u0026#34;Offset of color: {}\\n\u0026#34;, .{@offsetOf(RB_Node, \u0026#34;color\u0026#34;)}); zig语言的anytype只用于函数的参数声明（其他都不能用，函数的返回类型也不能用anytype）。\nzig 的test的函数必须是字符串，否则必须是标识符，一般和某个函数名的标识符相同，这样会作为该函数的文档测试说明。test函数的默认返回类型是错误联合类型，也就是!void\n这个网页说明了一些用法\nzig语言的error类型会自动赋一个整数值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const FileOpenError = error{ AccessDenied, OutOfMemory, FileNotFound, }; const AllocationError = error{ OutOfMemory, }; pub fn main() !void { const errort = FileOpenError.OutOfMemory; const err_int = @intFromError(errort); const err_int1 = @intFromError(AllocationError.OutOfMemory); dprint(\u0026#34;value errot:{},{}\\n\u0026#34;, .{ err_int, err_int1 }); } zig语言的catch是个二元运算符,value = expression catch default_value;，含义：\n如果 expression 成功（返回 T 类型的值），则 value 被赋值为该值。 如果 expression 返回错误（error 类型），则 value 被赋值为 default_value。 如:\n1 const number = parseU64(str, 10) catch 13; 在 Zig 中，catch 还支持一种扩展形式，允许你在捕获错误时执行自定义逻辑。这种用法的语法是：\n1 2 value = expression catch |err| { /* handle error */ }; expression catch |err| return err;这个语句完全等价try。 错误联合类型可以用if语句解包，但必须包含else分支，否则报错，也可以用while解包，但也需要包含else分支，否则报错。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const a: anyerror!u32 = error.AlwaysError; if (a) |value| { std.debug.print(\u0026#34;type a{}\\n\u0026#34;, .{value}); // 处理正常值 } else |err| { std.debug.print(\u0026#34;type a{}\\n\u0026#34;, .{err}); // 处理错误（必须显式捕获err） } fn fetchData() anyerror!u32 { // 模拟可能失败的操作 return if (std.crypto.random.int(u32) % 2 == 0) 42 else error.FetchFailed; } pub fn main() void { var retry: u32 = 0; while (fetchData()) |data| { std.debug.print(\u0026#34;Data: {}\\n\u0026#34;, .{data}); retry += 1; if (retry \u0026gt;= 3) break; // 防止无限循环 } else |err| { std.debug.print(\u0026#34;Error: {}\\n\u0026#34;, .{err}); } } 上面的||捕获可以是|_|，即忽略捕获值。 zig语言的orelse也是二元运算符，用来解包可选类型，左右两边两个表达式为执行代码，const b= a orelse value其中a是可选类型，b的值是当a不为null时，b为a的解包值，否则b为value。也可以用.?可访问非null的值（如果是null会引发panic）,if(optional_value)|value|是最安全的用法，while也可以解包可选类型。\nzig语言的return,break,continue,unreachable，while(true){}属于noreturn类型的值，用法基本和c一样，return用于全局退出，break用于局部退出。所以标签块要用break退出.\nzig语言的noreturn 可以和任何类型兼容，所以任何表达式都可以使用noreturn赋值，但因为是noreturn 类型，赋值操作不会执行，只会影响控制。\n下面是标签块的使用，\n1 2 3 4 5 6 var y: i32 = 123; const x = blk: { y += 1; break :blk y; }; 下面展示了枚举变量的简洁写法，\n1 2 3 4 5 const Color = enum { red, @\u0026#34;really red\u0026#34;, }; const color: Color = .@\u0026#34;really red\u0026#34;; 容器级别变量具有静态生命周期，且顺序无关，并且是惰性分析的。容器级别变量的初始化值隐式为编译时。如果容器级别变量是const，则其值在编译时已知，否则是在运行时已知。\n1 2 3 4 5 6 7 8 9 10 11 var y:i32=add(10,x); const x: i32=add(12,34); test \u0026#34;container level variables\u0026#34;{ try expect(x==46); try expect(y==56); } fn add(a:i32,b:i32) i32{ return a+b; } const std= @import(\u0026#34;std\u0026#34;) const expect= std.testing.expect; zig语言的const变量尽量会在编译器赋值或者初始化，尤其是在容器内的const变量只会在编译时赋值。\n如果想让var变量的初始化也在编译时进行，可以\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 test \u0026#34;comptime vars\u0026#34; { var x: i32 = 1; comptime var y: i32 = 1; x += 1; y += 1; try expect(x == 2); try expect(y == 2); if (y != 2) { // This compile error never triggers because y is a comptime variable, // and so `y != 2` is a comptime value, and this if is statically evaluated. @compileError(\u0026#34;wrong y value\u0026#34;); } } zig语言的切片和数组（array）的区别似乎只是固定长度和动态长度的区别。而且数组不能转化为指针和切片，只有数组的指针才能转化为切片和指向多个元素的指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const all_zero = [_]u16{0} ** 10; const Point = struct { x: i32, y: i32, }; test \u0026#34;compile-time array initialization\u0026#34; { try expect(fancy_array[4].x == 4); try expect(fancy_array[4].y == 8); } // call a function to initialize an array var more_points = [_]Point{makePoint(3)} ** 10; fn makePoint(x: i32) Point { return Point{ .x = x, .y = x * 2, }; } zig语言数组的初始化用法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const all_zero = [_]u16{0} ** 10; comptime { assert(all_zero.len == 10); assert(all_zero[5] == 0); } const Point = struct { x: i32, y: i32, }; test \u0026#34;compile-time array initialization\u0026#34; { try expect(fancy_array[4].x == 4); try expect(fancy_array[4].y == 8); } // call a function to initialize an array var more_points = [_]Point{makePoint(3)} ** 10; fn makePoint(x: i32) Point { return Point{ .x = x, .y = x * 2, }; } 虽然数组和切片更相似，但是切片和数组指针存在默认转换,数组的指针可以默认转化为切片，反之不行(除非在编译阶段能确定切片长度，这样就可以把切片默认转化为数组指针)。数组指针也可以转化为多项指针。\n1 2 3 4 5 6 7 8 9 10 11 const bytes: *const [5:0]u8 = \u0026#34;hello\u0026#34;; dprint(\u0026#34;bytes type:{}\\n\u0026#34;, .{@TypeOf(bytes)}); // const slice: []const u8 = \u0026#34;slice\u0026#34;; const slice: []const u8 = bytes;\\\\数组的指针转化为切片 dprint(\u0026#34;slice type:{}\\n\u0026#34;, .{@TypeOf(slice)}); const array: [5]u8 = [5]u8{ 1, 2, 3, 4, 5 }; const array_ptr = \u0026amp;array; dprint(\u0026#34;array type:{}\\n\u0026#34;, .{@TypeOf(array_ptr)}); const array_ptr1: [*]const u8 = \u0026amp;array;\\\\数组的指针转化为指向多个元素的指针。 dprint(\u0026#34;array type1:{}\\n\u0026#34;, .{@TypeOf(array_ptr1)}); 单个的指针ptr可以通过ptr[0..1]转化为切片（但是会在编译阶段优化为数组的指针）。\n在 switch 中，范围使用了三个点，即 3...6，而这个示例中，范围使用了两个点，即 0..10。这是因为在 switch 中，范围的两端都是闭区间，而 for 则是左闭右开。\nzig语言的函数参数默认是const，即不能修改参数的值。\n下面是while的用法，支持一个额外的每次运行的表达式。\n1 2 3 4 5 6 7 8 9 10 11 test \u0026#34;while loop continue expression, more complicated\u0026#34; { var i: usize = 1; var j: usize = 1; while (i * j \u0026lt; 2000) : ({ i *= 2; j *= 3; }) { const my_ij = i * j; try expect(my_ij \u0026lt; 2000); } } 其实while也是个表达式，它的值既可以是while循环里break value返回的value，也可以是else表达式返回的值.\n1 2 3 4 5 6 7 8 fn rangeHasNumber(begin: usize, end: usize, number: usize) bool { var i = begin; return while (i \u0026lt; end) : (i += 1) { if (i == number) { break true; } } else false; } 1 2 3 4 5 6 7 8 9 10 11 fn myfun()!void{ var buf: [30]u8 = undefined; //在这里try语句遇到错误会从终止函数并返回错误结果，因为stdin.readUntilDelimiterOrEof(\u0026amp;buf, \u0026#39;\\n\u0026#39;)的返回值类型为`!?[]u8`，所以 //if语句解包的是可选类型，得到|line| if (try stdin.readUntilDelimiterOrEof(\u0026amp;buf, \u0026#39;\\n\u0026#39;)) |line| { } } 在函数的泛型参数中anytype和comptime T:type，我没有看到本质区别。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const std = @import(\u0026#34;std\u0026#34;); const expect = std.testing.expect; const ComplexTypeTag = enum { ok, not_ok, }; const ComplexType = union(ComplexTypeTag) { ok: u8, not_ok: void, }; test \u0026#34;modify tagged union in switch\u0026#34; { var c = ComplexType{ .ok = 42 }; switch (c) { ComplexTypeTag.ok =\u0026gt; |*value| value.* += 1, ComplexTypeTag.not_ok =\u0026gt; unreachable, } try expect(c.ok == 43); } defer是在作用域退出时执行表达式，表达式当然可以是块（block）。defer , if , while,for ,switch关键字都是控制语句，后面如果是单个语句要加;, 如果是{}不加分号。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 onst std = @import(\u0026#34;std\u0026#34;); const expect = std.testing.expect; const print = std.debug.print; fn deferExample() !usize { var a: usize = 1; { defer a = 2; a = 1; } try expect(a == 2); a = 5; return a; } test \u0026#34;defer basics\u0026#34; { try expect((try deferExample()) == 5); } 额外说明 经过测试，结构体内部的函数和成员变量不能重名，block的标签名可以重名（除了嵌套）。\nzig的import导入模块的话，如果是直接@import 文件名的话，相对路径是相对于该导入文件的路径。\nzig的defer后面语句只能是void,也就是函数或者块不能返回值。\n风格指南\n请注意，下面的代码中a不是二维数组，它是一维数组，每个分量是切片。同理window_name是一维数组，由于切片，数组指针，指向多项的指针三者存在默认转换关系，所以window_name的每个分量是个指向多项的数组。\n1 2 const a=[_][]const u8{ \u0026#34;src\u0026#34;, \u0026#34;test\u0026#34;, \u0026#34;example\u0026#34; } const window_name = [1][*:0]const u8{\u0026#34;window name\u0026#34;}; zig语言的构建系统 zig语言的build.zig中，每个module或者test的root_source_file只能指向一个.zig文件（必须是相对路径），不可以是路径。\n示例：\n1 2 3 exe.addModule(\u0026#34;my_module\u0026#34;, .{ .root_source_file = .{ .path = \u0026#34;src/my_module\u0026#34; }, // 这里是目录 }); 然后在你的代码里可以这样用：\n1 2 const foo = @import(\u0026#34;my_module/foo.zig\u0026#34;); const bar = @import(\u0026#34;my_module/bar.zig\u0026#34;); 1. addModule 作用：创建一个模块，并将其添加到当前包的模块集合（b.modules）。\n可见性：公开（public）。这个模块会被暴露给依赖当前包的其他包（即作为 package 的“导出模块”）。\n典型用途：当你希望你的库/包对外暴露一个或多个模块时，使用 addModule。\n调用方式：\n1 const my_mod = b.addModule(\u0026#34;my_mod\u0026#34;, .{ .root_source_file = ... }); 效果：其他包可以通过 @import(\u0026quot;my_mod\u0026quot;) 访问这个模块。\n2. createModule 作用：创建一个模块，但不添加到包的模块集合，仅供当前包内部使用。 可见性：私有（private）。这个模块不会被暴露给依赖当前包的其他包。 典型用途：当你只需要在当前包内部组织代码、复用代码，但不希望对外暴露时，使用 createModule。 调用方式： 1 const my_private_mod = b.createModule(.{ .root_source_file = ... }); 效果：只能在当前包的 build 脚本中通过 addImport 等方式引用，外部包无法通过 @import 访问。 总结对比表 函数名 是否加入 b.modules 是否对外暴露 用途 addModule 是 是 对外暴露的模块 createModule 否 否 仅包内私有的模块 zig fetch zig fetch --save \u0026quot;git+https://github.com/用户/仓库.git#\u0026lt;commit_hash或者tag\u0026gt;\u0026quot;\n如果省掉#\u0026lt;commit_hash或者tag\u0026gt;就会拉取默认分支的最新的提交\n1 zig fetch --save=glfw \u0026#34;git+https://github.com/glfw/glfw.git\u0026#34; 下面测试也是可以的，但是不稳定，因为分支会变动\n1 zig fetch --save https://github.com/webui-dev/zig-webui/archive/main.tar.gz 如果自己手动填写url时，格式为\nhttps://github.com/\u0026lt;用户名\u0026gt;/\u0026lt;仓库名\u0026gt;/archive/\u0026lt;commit或tag\u0026gt;.tar.gz\n可以在build.zig中添加传递参数\n1 2 3 4 const exe = b.addExecutable(...); if (b.args) |args| { exe.addArgs(args); // 将构建参数传递给可执行文件 } 然后在程序中使用参数\n1 2 3 4 5 6 7 8 9 10 pub fn main() !void { const args = try std.process.argsAlloc(std.heap.page_allocator); defer std.process.argsFree(std.heap.page_allocator, args); // args[0]是程序名，args[1..]才是实际参数 for (args[1..]) |arg| { std.debug.print(\u0026#34;参数: {s}\\n\u0026#34;, .{arg}); } } 和外部（比如C）交互 1 2 3 4 5 6 7 8 9 10 const cstdio = @cImport({ // See https://github.com/ziglang/zig/issues/515 @cDefine(\u0026#34;_NO_CRT_STDIO_INLINE\u0026#34;, \u0026#34;1\u0026#34;); @cInclude(\u0026#34;stdio.h\u0026#34;); }); pub fn main() void{ _ = cstdio.printf(\u0026#34;hello\\n\u0026#34;); } 上面展示了引入c头文件的功能，需要在编译文件build.zig中添加exe.linkLibC();\nextern关键字表示在链接时才确定的符号，一般用在zig调用外部符号\n1 2 3 4 5 6 // extern声明用于声明将在链接时、静态链接时或运行时动态链接的函数。 // extern 关键字后的引号标识符指定具有该函数的库。（例如，“c”-\u0026gt;libc.so） // callconv 标记更改了函数的调用约定。 const WINAPI: std.builtin.CallingConvention = if (native_arch == .x86) .Stdcall else .C; extern \u0026#34;kernel32\u0026#34; fn ExitProcess(exit_code: u32) callconv(WINAPI) noreturn; extern \u0026#34;c\u0026#34; fn atan2(a: f64, b: f64) f64; ","date":"2025-04-28T00:00:00Z","image":"https://wujilingfeng.github.io/p/%E5%AD%A6%E4%B9%A0zig/fanchuan_hu_de82c3423caf9845.png","permalink":"https://wujilingfeng.github.io/p/%E5%AD%A6%E4%B9%A0zig/","title":"学习zig"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://wujilingfeng.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash.zh-cn_hu_2307260c751d0e0b.jpg","permalink":"https://wujilingfeng.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://wujilingfeng.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://wujilingfeng.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://wujilingfeng.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://wujilingfeng.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://wujilingfeng.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://wujilingfeng.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://wujilingfeng.github.io/p/emoji-support/","title":"Emoji Support"}]