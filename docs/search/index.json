[{"content":"","date":"2025-08-15T21:38:04+08:00","permalink":"https://wujilingfeng.github.io/p/%E6%B1%82%E5%92%8C%E6%9E%81%E9%99%90%E6%AC%A1%E5%BA%8F/","title":"求和极限次序"},{"content":"这是pdf\n以下空间均假设为概率空间，也就是总测度为1。\npdf中定义了随机变量，那么随机变量x期望的定义是$E\\left(x\\right)=\\int_{-\\infty}^{+\\infty} xd\\mu\\left(x\\right)$。\n由期望的定义知道如下结论\n如果随机变量x,y相互独立，那么$E\\left(xy\\right)=E\\left(x\\right)E\\left(y\\right)$，这是因为Fubini定理。 协方差的定义是$E\\left(\\left(x-E\\left(x\\right)\\right)\\left(y-E\\left(y\\right)\\right)\\right)=\\int_{-\\infty}^{+\\infty} \\left(x-\\overline{x}\\right)\\left(y-\\overline{y}\\right)d\\mu\\left(x,y\\right)$,由上面的定义知道协方差的定义需要知道联合概率密度$\\mu\\left(x,y\\right)$(联合测度)。\n但是在实际应用中使用者(统计领域无法像传统数学一样严禁)的不严谨往往导致人们忽略其定义，从而导致其他知识点和定理的无法贯通。有些例子甚至是错误的。\n且看下面的例子:\n现有采样数据\n$$y_1=[1,2]\\\\\\\\ y_2=[4,5]\\\\\\\\ y_3=[7,8]\\\\\\\\ y_4=[1,1]\\\\\\\\ y_5=[3,4]$$,那么期望 $$\\mu_1=\\frac{(1+4+7+1+3)}{5}=3.2\\\\\\\\ \\mu_2=\\frac{(2+5+8+1+4)}{ 5}=4$$，协方差为 $cov\\left(x_1,y_2\\right)=\\frac{(1-3.2)(2-4)+(4-3.2)(5-4)+(7-3.2)(8-4)+(1-3.2)(1-4)+(3-3.2)(4-4)}{5}$\n在这个例子中联合测度已经默认这样定义了$y_i=\\frac{1}{5}$,其他的则为0。\n在下面这个例子中，则完全错误：错误的例子\n","date":"2025-08-15T17:29:37+08:00","image":"https://wujilingfeng.github.io/p/%E6%B5%8B%E5%BA%A6%E8%AE%BA/image_hu_7130049abd617905.png","permalink":"https://wujilingfeng.github.io/p/%E6%B5%8B%E5%BA%A6%E8%AE%BA/","title":"测度论"},{"content":"经典微分几何 定理1 参数t是弧长参数s，的充分必要条件是$|r^{\u0026rsquo;} \\left(t\\right)|=1$\nproof: $|r^{\u0026rsquo;} \\left(t\\right)|dt=ds$ 本文以下未加说明，参数全部是弧长参数\n有向正则曲线 $t\\left(u\\right)$三次可微\n$t^{‘}$不为0\n曲线的主法向量 $r^{``}\\left(s\\right)$是曲线的主法向量，模长为曲率k(s是弧长)\nfrenet标架场和挠率 记$r^{‘}=\\alpha,r^{“}=k\\beta,\\gamma=\\alpha\\times\\beta$,则$\\alpha,\\beta,\\gamma$是frenet标架场，$|\\gamma^{‘}|=\\tau$为挠率\nfrenet矩阵 $$\\left(\\begin{matrix}\\ \\alpha^{'}\\\\\\\\ \\beta^{'}\\\\\\\\ \\gamma^{‘} \\end{matrix}\\right)=\\left(\\begin{matrix} 0\u0026k\u00260\\\\\\\\ -k\u00260\u0026\\tau\\\\\\\\ 0\u0026-\\tau\u00260 \\end{matrix}\\right)\\left(\\begin{matrix} \\alpha\\\\\\\\ \\beta\\\\\\\\ \\gamma \\end{matrix}\\right)$$ 其实对于正交坐标架他的微分矩阵都是反对称的\n有如下命题:\n$A^TA=I,dA^TA+A^TdA=0,A=I,dA+dA^T=0$ **\n曲线基本定理 在3维空间中给定矩阵F，坐标架$\\alpha,\\beta,\\gamma$（不一定正交，不一定单位模长） $$d\\left(\\begin{matrix} \\alpha\\\\\\\\ \\beta\\\\\\\\ \\gamma \\end{matrix}\\right)=F\\left(\\begin{matrix} \\alpha\\\\\\\\ \\beta\\\\\\\\ \\gamma \\end{matrix}\\right)ds$$ 这是线性常微分方程，给定初始$\\alpha^0,\\beta^0 \\gamma^0$.则曲线唯一确定（相差一个刚体变换）。\n隐函数定理 对于方程组$0=y_i\\left(x_j\u0026hellip;\\right),n \\le i\u0026gt;0 ,m \\le j\u0026gt;0,m\u0026gt;n$,若有,$\\frac{\\partial \\left(y_1,y_2..y_n\\right)}{\\partial \\left(x_1,..x_n\\right)}$满秩，那么$x_1,..x_n$可以表示成$x_{n+1}\u0026hellip;x_m$的函数\n*proof *:\n$\\frac{\\partial y}{\\partial x}dx=0$,得到$\\frac{\\partial \\left(y_1,y_2..y_n\\right)}{\\partial \\left(x_1,..x_n\\right)}\\left(dx_1..\\right)=-\\frac{\\partial \\left(y_1,y_2..y_n\\right)}{\\partial \\left(x_{n+1},..x_m\\right)}\\left(dx_{n+1}\u0026hellip;\\right)$,\n左边存在逆矩阵，乘到右边，再积分即得证。\n正则曲面 曲面$r\\left(u,v\\right)$的$r_{u}$和$r_{v}$线性无关1\n曲面的第一基本形式 曲面的度量张量称为第一基本形式\n$$\\left(\\begin{matrix} E\u0026F\\\\\\\\ F\u0026G \\end{matrix}\\right)$$或者$ds^2=Edu^2+2Fdudv+Gdv^2$ 度量g还有重要的写法是 $$A=\\left(\\begin{matrix} \\sqrt{E}\u0026\\frac{F}{\\sqrt{E}}\\\\\\\\ 0\u0026\\sqrt{G-\\frac{F^2}{E}} \\end{matrix}\\right),g=A^TA$$ 用来求平均曲率和gauss曲率。\n曲面上正交参数的存在性（不是等温坐标系）2 曲面的第二基本形式 设n为曲面点p处的法向量($du\\wedge dv$),那么$\u0026lt;d^2 r,n\u0026gt;$为第二基本形式，因为$\u0026lt;dr,n\u0026gt;=0$,所以$\u0026lt;d^2 r,n\u0026gt;=-\u0026lt;dr, dn \u0026gt;$\n曲面上曲线的法曲率 $\u0026lt;d^2 r\\left(s\\right),n\u0026gt;$称为曲线的法曲率，s为弧长参数.\n经过化简的到\n$$\\frac{Ldu^2+2Mdudv+Ndv^2}{ds^2}=\\frac{Ldu^2+2Mdudv+Ndv^2}{Edu^2+2Fdudv+Gdv^2}$$由式子知道法曲率只跟切向量(du,dv)相关，所以我们可以考虑由法截面截取的曲线的法曲率。\n主曲率和主方向 每点的法曲率的最大值和最小值称为该点的两个主曲率，两个方向称为该点的主方向。\n平均曲率和gauss曲率 两个主曲率之和是平均曲率，两个主曲率之积是gauss曲率。gauss曲率在黎曼流形上的推广是截面曲率。\n曲面上自然标架场和微分 曲面上的自然标架場是${ r_1,r_2,n }$,记第一基本形式的张量为$g_{\\alpha \\beta}$，它的逆是$g^{\\alpha \\beta}$,第二基本形式张量为$b_{\\alpha \\beta}$,它的逆是$b^{\\alpha \\beta}$,\n如果命$b_{\\alpha}^{\\gamma}=b_{\\alpha t}g^{t \\gamma}$为指标的上升,以后指标的上升与下降都是这样的关系。\n那么自然标架的微分 $$\\frac{\\partial r_{\\alpha}}{\\partial u^{\\beta}}= b_{\\alpha \\beta}n+r_{\\gamma}\\Gamma^{\\gamma}_{\\alpha \\beta}$$和\n$$\\frac{\\partial n}{\\partial u^{\\beta}}=-b_{\\beta}^{\\gamma}r_{\\gamma}$$计\n$$\\Gamma^{\\gamma}_{\\alpha \\beta}=g^{\\gamma i}\\Gamma _{i\\alpha \\beta}$$（指标的上升）,\n$$\\Gamma _{\\gamma \\alpha \\beta}=\\frac{1}{2}\\left(\\frac{\\partial g _{\\alpha \\gamma}}{\\partial u^{\\beta}}+\\frac{\\partial g _{ \\gamma \\beta}}{\\partial u^{\\alpha}}-\\frac{\\partial g _{\\alpha \\beta}}{\\partial u^{\\gamma}}\\right)$$$$\\Gamma^{\\gamma}_{\\alpha \\beta}=g^{\\gamma i}\\Gamma _{i\\alpha \\beta}=\\frac{1}{2}g^{\\gamma i}\\left(\\frac{\\partial g _{\\alpha \\gamma}}{\\partial u^{\\beta}}+\\frac{\\partial g _{ \\gamma \\beta}}{\\partial u^{\\alpha}}-\\frac{\\partial g _{\\alpha \\beta}}{\\partial u^{\\gamma}}\\right)$$ 由上知自然标架的christoffel符号是內蕴的 证明见微分几何初步(陈维桓)P.128\n曲面唯一性定理 （在刚体变换意义下）在$E^3$中，第一基本形式和第二基本形式决定了唯一一个曲面\n自然标架场的微分方程组是\n$$d\\left(\\begin{matrix} r _{1}\\\\\\\\ r _{2}\\\\\\\\ n \\end{matrix}\\right)=\\left(\\begin{matrix}\\left(\\Gamma^{\\gamma} _{1 \\beta}r _{\\gamma}+b _{1 \\beta}n\\right)d\\beta\\\\\\\\ \\left(\\Gamma^{\\gamma} _{2 \\beta}r _{\\gamma}+b _{2 \\beta}n\\right)d\\beta\\\\\\\\ \\left(-b^{\\gamma} _{\\beta}r _{\\gamma}\\right)d\\beta \\end{matrix}\\right)$$ 这是个偏微分方程组，如果给定第一基本量，和第二基本量，再给定初始条件，和\n$$dd\\left(\\begin{matrix} r _{1}\\\\\\\\ r _{2}\\\\\\\\ n \\end{matrix}\\right)=0$$,(dd是二次外微分，化简得到Gauss-Codazzi方程)，那么存在唯一的自然标架場是方程的解。\nGauss-Codazzi方程 记$R^{\\delta} _{\\alpha\\beta\\gamma}=\\frac{\\partial \\Gamma^{\\delta} _{\\alpha\\gamma}}{\\partial u^{\\beta}}-\\frac{\\partial \\Gamma^{\\delta} _{\\alpha\\gamma}}{\\partial u^{\\beta}}+\\Gamma^{\\eta} _{\\alpha\\beta}\\Gamma^{\\delta} _{\\eta\\beta}-\\Gamma^{\\eta} _{\\alpha\\gamma}\\Gamma^{\\delta} _{\\eta\\beta}$,同理$R _{\\delta\\alpha\\beta\\gamma}=g _{\\delta\\eta}R^{\\eta} _{\\alpha\\beta\\gamma}$ 那么$R^{\\delta} _{\\alpha\\beta\\gamma}=b _{\\alpha\\beta}b _{\\gamma}^{\\delta}-b _{\\alpha\\gamma}b _{\\beta}^{\\delta}$或者$R _{\\delta\\alpha\\beta\\gamma}=-\\left(b _{\\delta\\beta}b _{\\alpha\\gamma}-b _{\\delta\\gamma}b _{\\alpha\\beta}\\right)$称为gauss方程， $\\frac{\\partial b _{\\alpha\\beta}}{\\partial u^{\\gamma}}-\\frac{\\partial b _{\\alpha\\gamma}}{\\partial u^{\\beta}}=b _{\\beta\\delta}\\Gamma^{\\delta} _{\\alpha\\gamma}-b _{\\gamma\\delta}\\Gamma^{\\delta} _{\\alpha\\beta}$称为Codazzi方程.曲面方程的存在的充分必要条件是满足Gauss-codazzi方程。\ngauss theorem 求$\\frac{Ldu^2+2Mdudv+Ndv^2}{Edu^2+2Fdudv+Gdv^2}$,的最大值和最小值之积是$\\frac{|b|}{|g|}=|b||g^{-1}|$,因为$R _{\\delta\\alpha\\beta\\gamma}=g _{\\delta\\eta}R^{\\eta} _{\\alpha\\beta\\gamma}$，可以看出gauss曲率的值是等矩不变量。3\n测地曲率，测地挠率 在曲面S上有曲线$u^{\\alpha}\\left(s\\right)$,在曲线上取正交正规坐标架\n$e _{i}$,其中$e _{1}=\\frac{dr\\left(s\\right)}{ds}$,$e _{2}=n\\times e _{1}$,$e _{3}=n$,\n对坐标架微分得到\n$$d\\left(\\begin{matrix}\\ e _{1}\\left(s\\right)\\\\\\\\ e _{2}\\left(s\\right)\\\\\\\\ e _{3}\\left(s\\right) \\end{matrix}\\right)=M\\left(\\begin{matrix}\\ e _{1}\\left(s\\right)\\\\\\\\ e _{2}\\left(s\\right)\\\\\\\\ e _{3}\\left(s\\right) \\end{matrix}\\right)ds$$,由上知M是反对称矩阵，那么$M _{12}$称为测地曲率，$M _{23}$称为测地挠率，$M _{13}$是曲线的法曲率.\n$M _{12}=\\left(n\\times e _1\\right)*e^{`} _1=\\left(n,e _1,e^{\u0026rsquo;} _1\\right)$,其中三个量都是保长不变量，所以测地曲率是保长不变量。\n测地线 曲面上测地曲率等于0的曲线\n曲面上向量场的平行移动 Gauss-Bonnet公式 在黎曼流形上当度量张量不变时，外微分的积分可以按正常积分计算，但外积符号$\\wedge$不可丢。\nStokes 公式 Poincare Lemma 闭形式但不是恰当形式的例子:\n定义在$R^2-0$上的1-form $\\eta=\\frac{xdy-ydx}{x^2+y^2}$沿不同闭曲线的积分\n定义在$R^3-0$上的2-form $\\eta=\\frac{xdy\\wedge dz+ydz\\wedge dx+zdx\\wedge dy}{\\left(x^2+y^2+z^2\\right)^{\\frac{3}{2}}}$\n现代微分几何 Definition（流形的凸性） 可定向流形流形的方向是单射。（准确的说可定向流形有一个类似gauss映射的推广函数，它是单射）\n梯度算子 梯度算子并不是微分算子，它是$C^{\\infty}\\left(M\\right)\\to TM$即光滑函数到切空间的映射。\n他有两个作用，第一个就是定义所说的可以通过度量张量来表示$X\\left(f\\right)$,\n第二个作用是梯度算子的结果是所有$|X|_g=1,X\\in TM$,使得$X\\left(f\\right)$最大的切方向。\nRicci flow 给一个黎曼流形M,配有黎曼度量$g _{0}$.\n假设度量矩阵g是关于t的函数，且这个函数由常微分方程组$\\frac{dg _{ij}}{dt}=-2 R _{ij}$，初始条件$g\\left(0\\right)=g _0$确定。$R _{ij}$是Ricci tensor.那么$g\\left(t\\right)$是Ricci flow\n黎曼流形上的散度算子 这里\n这里\nlaplace算子在流形上的推广为拉普拉斯-贝尔特拉米算子,在微分形式上的推广是拉普拉斯–德拉姆算子。\n拉普拉斯-贝尔特拉米算子\nStokes公式 在Rudin的一书中有Stokes公式的证明\nPoincare引理 概括而言正则流形是每点切空间和流形维数相同\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n维数大于等于3的黎曼流形不一定存在正交参数系。正交坐标系要求第一基本形式F=0，等温坐标系要求F=0,E=G(保角).\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n內蕴几何是研究等矩变换不变量的几何，但是等矩变换不是保持度量g一直不变\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-08-15T17:15:58+08:00","image":"https://wujilingfeng.github.io/p/%E5%BE%AE%E5%88%86%E5%87%A0%E4%BD%95/image_hu_2248ac0919b0c155.png","permalink":"https://wujilingfeng.github.io/p/%E5%BE%AE%E5%88%86%E5%87%A0%E4%BD%95/","title":"微分几何"},{"content":"将使用 Dawn 库编写的渲染程序导出到 Web 端和本地端，需要采取不同的编译和部署策略，但核心思想是：你的 C++ 渲染逻辑（使用 WebGPU API）大部分可以保持不变，而平台特定的部分（如窗口创建、文件IO、事件处理）则需要抽象或有条件编译。\nDawn 本身是一个 C++ 库，实现了 WebGPU API 规范，并且是 Chromium 浏览器中 WebGPU 的底层实现。\n核心思想：平台无关的 WebGPU 逻辑 你的渲染程序主体应该使用 WebGPU API（通过 wgpu::Device, wgpu::Queue, wgpu::RenderPassEncoder 等）来定义渲染管线、加载资源、绘制等。这部分代码在概念上是平台无关的。\n然而，创建窗口/画布、获取 WebGPU 设备、处理用户输入等部分是与平台紧密相关的。\n1. 导出到 Web 端 (浏览器) 在 Web 端，你的 C++ 代码需要被编译成 WebAssembly (WASM)，并在浏览器环境中运行。浏览器本身提供了原生的 WebGPU API 实现（在 Chromium 中，这个实现就是基于 Dawn 的）。这意味着你不需要将 Dawn 库本身编译进你的 WASM 包，你的 WASM 直接调用浏览器提供的 WebGPU API。\n主要工具：Emscripten\n编写 C++ 渲染程序：\n你的渲染代码会调用标准的 WebGPU API（封装在 Dawn 的 C++ 头文件中，如 dawn/webgpu.h 或直接使用 wgpu 名称空间）。\n对于画布的创建和获取 WebGPU 设备，你需要使用 Emscripten 提供的接口来与 JavaScript 环境交互。例如，获取 navigator.gpu 和请求设备。\n示例（概念性）：\n#include \u0026lt;webgpu/webgpu.h\u0026gt; // 使用 WebGPU API // Emscripten 提供的用于与 JS 交互的宏 #include \u0026lt;emscripten/emscripten.h\u0026gt; #include \u0026lt;emscripten/html5.h\u0026gt; WGPUAdapter g_adapter = nullptr; WGPUDevice g_device = nullptr; WGPUQueue g_queue = nullptr; // C++ 函数，通过 Emscripten 暴露给 JS extern \u0026#34;C\u0026#34; EMSCRIPTEN_KEEPALIVE void init_webgpu(WGPUSurface surface_ptr) { // ... (请求 adapter, device, queue, config shader module, pipeline etc.) // 通常这一步需要异步回调，与 JS 交互 // Emscripten 提供了异步回调机制，如 emscripten_async_call 或 Promise 桥接 } // 渲染循环（通过 JS requestAnimationFrame 调用） extern \u0026#34;C\u0026#34; EMSCRIPTEN_KEEPALIVE void draw_frame() { if (!g_device) return; // ... (创建 command encoder, render pass, draw calls, submit commands) } int main() { // Emscripten_main_loop_set_timing(EM_HTML5_LOOP_RAF, 1); // 绑定到 requestAnimationFrame // 这是通常的 Emscripten 主循环设置，而不是无限循环 return 0; // Emscripten 的 main 函数返回后不会退出程序 } 你需要处理异步操作（如 requestAdapter 和 requestDevice）以及如何将 WASM 渲染循环与 requestAnimationFrame 绑定。Emscripten 提供了相应的机制。\n使用 Emscripten 编译：\nEmscripten 编译命令会有点复杂，因为它需要知道你的 WebGPU 定义，但不会链接 Dawn 库本身：\nemcc your_renderer.cpp -o your_renderer.html \\ -s USE_WEBGPU=1 \\ -s ASYNCIFY \\ -s EXPORTED_FUNCTIONS=\u0026#34;[\u0026#39;_init_webgpu\u0026#39;, \u0026#39;_draw_frame\u0026#39;]\u0026#34; \\ -s NO_EXIT_RUNTIME=1 \\ -s FORCE_FILESYSTEM=1 # 如果有文件加载 # ... 其他 Emscripten 参数 -s USE_WEBGPU=1：告诉 Emscripten，你的 C++ 代码将使用 WebGPU API，它会引入必要的 JS 胶水代码，并期望浏览器提供 WebGPU API。\n-s ASYNCIFY：如果你的 WebGPU 初始化过程包含异步操作（如 requestAdapter），你需要它来暂停 C++ 执行直到异步操作完成。\n-s EXPORTED_FUNCTIONS：暴露 C++ 函数给 JavaScript 调用。\nNO_EXIT_RUNTIME=1：防止 WASM 模块在 main() 函数结束后立即退出。\nWeb 页面 (HTML/JavaScript)：\nEmscripten 会生成一个 .html 文件和一个 .js 胶水文件，以及 .wasm 文件。\nJavaScript 会负责加载 WASM 模块，创建一个 \u0026lt;canvas\u0026gt; 元素，然后通过 Emscripten 暴露的 C++ 函数来初始化 WebGPU，并设置 requestAnimationFrame 循环来调用 WASM 中的 draw_frame 函数。\n示例 (your_renderer.js / your_renderer.html 内部的 JS):\nvar Module = { preRun: [], postRun: [], print: (function() { /* ... */ })(), printErr: (function() { /* ... */ })(), canvas: (function() { var canvas = document.getElementById(\u0026#39;canvas\u0026#39;); // Emscripten 会自动将其绑定到渲染上下文 return canvas; })(), setStatus: (function() { /* ... */ })(), totalDependencies: 0, monitorRunDependencies: function(left) { /* ... */ } }; // 异步加载 WASM 模块 Module.onRuntimeInitialized = async () =\u0026gt; { const canvas = Module.canvas; // Emscripten already binds the canvas const context = canvas.getContext(\u0026#39;webgpu\u0026#39;); // Get WebGPU context // Important: Get a WGPUSurface from the canvas context const surface = Module.WebGPUMakeSurfaceFromCanvasContext(context); // Call C++ init function, passing the surface pointer Module._init_webgpu(surface); // Assuming _init_webgpu expects a surface pointer // Setup render loop function frame() { Module._draw_frame(); requestAnimationFrame(frame); } requestAnimationFrame(frame); }; 请注意 WebGPUMakeSurfaceFromCanvasContext 是 Emscripten 在使用 USE_WEBGPU=1 时提供的一个辅助函数。\n2. 导出到本地端 (桌面应用) 在本地端，你的 C++ 程序将直接链接到 Dawn 库，并使用操作系统特定的接口（如 GLFW, SDL2, Native Windowing API）来创建窗口和管理事件。\n主要工具：C++ 编译器 (Clang, GCC, MSVC) + Dawn 库 + 窗口库\n构建 Dawn 库：\n你需要从 Dawn 的 GitHub 仓库 (https://dawn.googlesource.com/dawn 或 GitHub mirror) 克隆代码。 Dawn 使用 GN 和 Ninja 作为其构建系统。你需要按照 Dawn 仓库中的说明来构建它。这通常涉及： 安装 depot_tools (Google 的工具链管理)。 gclient sync 下载依赖。 gn gen out/Default 或 gn gen out/Debug 生成构建文件。 ninja -C out/Default 编译 Dawn。 这会生成 Dawn 的库文件（.lib, .a, .so, .dll 等取决于你的操作系统）。 编写 C++ 渲染程序：\n你的渲染代码会直接使用 Dawn 的 wgpu::Instance, wgpu::Adapter, wgpu::Device 等本地 Dawn 对象。 创建窗口：使用如 GLFW 或 SDL2 这样的库来创建 OS 窗口，并获取其 HWND (Windows), xcb_connection_t/Window (Linux X11), NSWindow (macOS) 等句柄。 通过 Dawn 的 wgpu::Instance::CreateSurface 方法，利用窗口句柄创建 wgpu::Surface。 示例（概念性）：\n#include \u0026lt;GLFW/glfw3.h\u0026gt; // 用于窗口管理 #include \u0026lt;dawn/webgpu_cpp.h\u0026gt; // 使用 Dawn 的 C++ 绑定 #include \u0026lt;dawn/native/DawnNative.h\u0026gt; // 用于 WGPUNativeInstance // 全局实例、Adapter、Device等 std::unique_ptr\u0026lt;dawn::native::Instance\u0026gt; g_instance; wgpu::Adapter g_adapter; wgpu::Device g_device; wgpu::Queue g_queue; wgpu::TextureFormat g_surfaceFormat; wgpu::Surface g_surface; void init_dawn_native(GLFWwindow* window) { g_instance = std::make_unique\u0026lt;dawn::native::Instance\u0026gt;(); g_instance-\u0026gt;DiscoverDefaultAdapters(); // 或手动选择 // 获取 SurfaceDescriptor 适配平台 #if defined(_WIN32) WGPUSurfaceDescriptorWindowsHWND surfaceDesc; surfaceDesc.chain.next = nullptr; surfaceDesc.chain.sType = WGPUSType_SurfaceDescriptorWindowsHWND; surfaceDesc.hinstance = GetModuleHandle(nullptr); surfaceDesc.hwnd = glfwGetWin32Window(window); WGPUSurfaceDescriptor sDesc; sDesc.nextInChain = reinterpret_cast\u0026lt;WGPUChainedStruct*\u0026gt;(\u0026amp;surfaceDesc); g_surface = g_instance-\u0026gt;CreateSurface(\u0026amp;sDesc); #elif defined(__APPLE__) // ... macOS specific surface creation #elif defined(__linux__) // ... Linux specific surface creation #endif // 请求 adapter 和 device // 这一步在本地通常是同步的，但在某些复杂配置下也可以异步 std::vector\u0026lt;wgpu::Adapter\u0026gt; adapters = g_instance-\u0026gt;Get Adapters(); if (adapters.empty()) return; The adapters here are wgpu::Adapter which are not exposed from the instance. adapters[0].RequestDevice(nullptr, [](WGPURequestDeviceStatus status, WGPUDevice cDevice, const char* message, void* userdata) { if (status == WGPURequestDeviceStatus_Success) { g_device = wgpu::Device::Acquire(cDevice); g_queue = g_device.GetDefaultQueue(); } else { // Error handling } }, nullptr); // ... (配置渲染管线等) } void draw_frame_native() { if (!g_device) return; // ... (创建 command encoder, render pass, draw calls, submit commands) } int main() { glfwInit(); glfwWindowHint(GLFW_CLIENT_API, GLFW_NO_API); // 禁用 OpenGL 上下文 GLFWwindow* window = glfwCreateWindow(800, 600, \u0026#34;Dawn Native\u0026#34;, nullptr, nullptr); init_dawn_native(window); // 初始化 Dawn while (!glfwWindowShouldClose(window)) { glfwPollEvents(); draw_frame_native(); // 渲染帧 } glfwDestroyWindow(window); glfwTerminate(); return 0; } 编译与链接：\n使用你的 C++ 编译器编译你的应用程序代码。 链接到你之前构建的 Dawn 库文件以及窗口库（如 GLFW）。确保编译器能找到头文件（-I）和库文件（-L）。 还需要链接到驱动程序 API（如 Vulkan, D3D12, Metal）的库，具体取决于 Dawn 的后端配置和你的目标平台。 总结与注意事项： 代码共享： 努力将核心的 WebGPU 渲染逻辑（管线创建、资源管理、绘制调用）放在一个平台无关的模块中。只有窗口创建、设备获取和主循环部分需要平台特化。 平台抽象： 可以引入一个抽象层，例如 IPlatform 接口，来处理窗口创建、事件监听和异步回调，然后针对 Web 和 Native 分别实现这个接口。 异步性： WebGPU API 本身就包含许多异步操作（requestAdapter, requestDevice, mapAsync），在 Web 端这天然是异步的，但在本地端，某些操作可能是同步或通过回调模拟异步。你需要兼容这种行为差异。 文件 I/O： 在 Web 端，直接文件 I/O 是受限的，通常需要通过 fetch API 或打包到 WASM 中；在本地端则可以自由访问文件系统。 调试： WebGPU 在浏览器中有强大的调试工具（例如 Chrome DevTools 中的 GPU 面板）。本地 Dawn 也有自己的调试层。 ","date":"2025-07-16T10:22:34+08:00","image":"https://wujilingfeng.github.io/p/web%E7%AB%AF%E6%B8%B2%E6%9F%93/img_hu_257651d1883e177a.png","permalink":"https://wujilingfeng.github.io/p/web%E7%AB%AF%E6%B8%B2%E6%9F%93/","title":"Web端渲染"},{"content":"zig语言中文社区\nzig编译为webassembly\nhttps://dev.to/sleibrock/webassembly-with-zig-part-1-4onm\nzig语言的type类型可以直接比较判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 pub fn normalize(p: anytype) Math_Compute_Abandon!void { comptime { const T=@TypeOf(p[0]); if(@TypeOf(p)!=[]T) { @compileError(\u0026#34;normalize error\\n\u0026#34;++@typeName(@TypeOf(p))++\u0026#34;fdsf\u0026#34;); } } const norm = lb_norm(p); if (approxEqAbs(@TypeOf(p[0]), norm, 0, null)) { return error.Math_Compute_Abandon; } for (p) |*pv| { pv.* /= norm; } } 下面是zig语言类型反射用法，包括访问struct类型，访问字段类型\n1 2 3 4 5 fn myget_Array_rows(comptime TT: type) usize { return @typeInfo(TT).array.len; } //下面有typeinfo的用法 pub fn mult(self: *const Self, mat: anytype) LBMatrix(T, rows, myget_Array_rows(@typeInfo(@TypeOf(mat)).@\u0026#34;struct\u0026#34;.fields[0].type)) mat的类型如下:\n1 2 3 4 5 struct { const Self = @This(); data: [rows][cols]T, } 似乎zig中的@import不能导入上层目录，也就是不能出现.. 。那也就意味着每个子文件夹里面的zig源文件都要独立成为一个自摸块，除了依赖子文件夹，不会依赖其他文件夹的zig源文件\ncomptime实战 1 2 3 4 5 6 7 8 9 10 11 12 13 14 test \u0026#34;inline while loop\u0026#34; { comptime var i = 0; // i 是一个编译期常量 var sum: usize = 0; // sum 是一个运行时变量 inline while (i \u0026lt; 3) : (i += 1) { const T = switch (i) { 0 =\u0026gt; f32, 1 =\u0026gt; i8, 2 =\u0026gt; bool, else =\u0026gt; unreachable, }; sum += typeNameLength(T); // typeNameLength 可能是一个编译期函数，用于获取类型名称的长度 } try expect(sum == 9); } 上面的例子中，如果i是不是comptime变量，就不能用inline while。\ndeepseek说只能写try comptime 而非comptime try ，可是下面的例子\n1 2 3 4 5 6 7 8 test \u0026#34;peer type resolution: ?T and T\u0026#34; { try expect(peerTypeTAndOptionalT(true, false).? == 0); try expect(peerTypeTAndOptionalT(false, false).? == 3); comptime { try expect(peerTypeTAndOptionalT(true, false).? == 0); try expect(peerTypeTAndOptionalT(false, false).? == 3); } } zig语言的切片[]T可以安全地转向[]const T ，不需要显式转换。\n下面的代码报错是因为没有确定类型导致类型推断冲突，因为x没有给类型，而-1是comptime_int,故而x是comptime_int类型，这和var冲突。\n1 2 3 4 5 6 test safe_sqrt { var x= -1;\\\\这里需改为var x:f32=-1;即可修复错误 x = x - 1; try std.testing.expect(safe_sqrt(x) \u0026gt;= 0); } 一般来说zig语言的绑定库只需要@cImport()该库的暴露的.h文件即可，但是有些时候会再在上面裹上一层zig的wrapper， 比如这个mach-glfw 里面的main分支，就是@cImport()之后又裹了一层zig。\n如果zig语言想要实现类型类，只需要写个满足类型类约束的comptime函数，也就是在编译期进行类型检查是否有某些方法的判断，然后在需要添加类型类约束的函数上添加这个编译期函数判断即可。\n编译系统 下面是编译c语言项目的构建代码，有冗余，这里的注释部分也能添加源文件，到底是cstructures_mod还是cstructures添加源文件呢？写法不统一。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const cstructures_mod = b.addModule(\u0026#34;cstructures_mod\u0026#34;, .{ .target = target, .optimize = optimize, .root_source_file = null, }); // cstructures_mod.addIncludePath(b.path(\u0026#34;cstructures/include\u0026#34;)); // cstructures_mod.addCSourceFiles(.{ // .files = \u0026amp;.{\u0026#34;cstructures/src/tools_node.c\u0026#34;}, // .flags = \u0026amp;.{ \u0026#34;-Wall\u0026#34;, \u0026#34;-O2\u0026#34; }, // }); const cstructures = b.addLibrary(.{ .linkage = .static, .name = \u0026#34;cstructures\u0026#34;, .root_module = cstructures_mod, }); cstructures.addIncludePath(b.path(\u0026#34;cstructures/include\u0026#34;)); cstructures.addCSourceFiles(.{ .files = \u0026amp;.{\u0026#34;cstructures/src/tools_node.c\u0026#34;}, .flags = \u0026amp;.{ \u0026#34;-Wall\u0026#34;, \u0026#34;-O2\u0026#34; }, }); cstructures.linkLibC(); 导出为webassembly 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.Build) void { const target = b.resolveTargetQuery(std.Target.Query.parse( .{ .arch_os_abi = \u0026#34;wasm32-wasi\u0026#34; }, ) catch unreachable); const exe = b.addExecutable(.{ .name = \u0026#34;main\u0026#34;, .root_source_file = b.path(\u0026#34;src/main.zig\u0026#34;), .target = target, .optimize = b.standardOptimizeOption(.{}), }); //注意这个选项 exe.rdynamic = true; //导出该可执行对象中标记了export的项目 // 此项默认为false，如果你需要在js环境中调用导出的方法，需要设置为true b.installArtifact(exe); //保存生成的结果 } 下面是ai生成测试用例\n编写 Zig 代码举例 以最小 Hello World 为例：\n// main.zig const std = @import(\u0026#34;std\u0026#34;); export fn add(a: i32, b: i32) i32 { return a + b; } 说明:\nexport 标记表明该函数将被导出到 WASM 模块，从 JS 里可调用。 编写 build.zig build.zig 是使用 Zig 提供构建脚本功能的新式方法。下面以导出 WASM 的例子说明：\nconst std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.Build) void { const target = b.standardTargetOptions(.{ .default_target = .{ .arch = .wasm32, .os_tag = .freestanding } }); const optimize = b.standardOptimizeOption(.{}); const exe = b.addExecutable(.{ .name = \u0026#34;zighello\u0026#34;, .root_source_file = .{ .path = \u0026#34;main.zig\u0026#34; }, .target = target, .optimize = optimize, }); // 控制输出为 WebAssembly (wasm) exe.setOutputFile(\u0026#34;zighello.wasm\u0026#34;); // 一般来说，Web 上不需要标准库 exe.stack_size = 64 * 1024; // 可选: 设置栈大小 exe.disable_stack_protector = true; // 可选: 关闭栈保护 b.default_step.dependOn(\u0026amp;exe.step); } 参数说明:\ntarget 选用了 .wasm32 和 .freestanding (面向浏览器用freestanding。若需要标准库，如文件io，则用 .wasm32-wasi) addExecutable 制作出可执行 WASM, 并命名和指向源代码 .setOutputFile 明确指定输出文件名 default_step.dependOn 确保执行默认构建流程 编译命令 在含有 build.zig 的目录下运行：\nsh zig build 正常情况下会输出 zighello.wasm 文件。\n用 JavaScript 加载 WASM 最基础的 JS 加载代码如下：\njsfetch(\u0026#39;zighello.wasm\u0026#39;) .then(response =\u0026gt; response.arrayBuffer()) .then(bytes =\u0026gt; WebAssembly.instantiate(bytes)) .then(results =\u0026gt; { // zighello.wasm 里由 zig export 的函数 const add = results.instance.exports.add; console.log(\u0026#39;zig add:\u0026#39;, add(33, 44)); // 输出 77 }); 注意事项\n用 wasm32-freestanding 方式 Zig 标准库很多功能不可用（如I/O） 若常用 Zig 标准库（如console打印、文件IO），应将目标置为 wasm32-wasi，并在 Node/服务器侧WASI环境执行 进阶提示 与 JS 更复杂的数据交互 WASM 只支持数字（int、float\u0026hellip;），字符串等需传递内存指针。 编译到 wasm32-wasi 可在 build.zig 里改为 .os_tag = .wasi，能用 std.io、环境变量等 自动产出 JS 绑定代码 可用 Zig 社区 wasm-bindings 或仅用 JS Fetch 加载 WebAssembly 与 Zig 版本 推荐使用最新 Zig 版本（如0.12.0及以上）以获得更好的 WASM 支持 参考更复杂的实际 build.zig 示例 适配多种目标，暴露参数给命令行：\nconst std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.Build) void { const target = b.standardTargetOptions(.{}); const optimize = b.standardOptimizeOption(.{}); const exe = b.addExecutable(.{ .name = \u0026#34;demo\u0026#34;, .root_source_file = .{ .path = \u0026#34;src/main.zig\u0026#34; }, .target = target, .optimize = optimize, }); exe.setOutputDir(\u0026#34;dist\u0026#34;); // 输出到dist文件夹 exe.setOutputFile(\u0026#34;demo.wasm\u0026#34;); b.installArtifact(exe); // 默认步骤 b.default_step.dependOn(\u0026amp;exe.step); } 常见问题 Q: 为什么JS调用WASM时找不到导出函数？ A: 需用 export fn ...，如果没用export明示导出，WASM模块不会暴露该函数。 Q: Zig标准库不能用/编译时报错？ A: wasmf32-freestanding下禁用 std，换用wasm32-wasi作为target 或手工实现基础IO。 Q: 如何编译为Emscripten兼容的WASM？ A: 目前Zig不直接输出专为Emscripten定制代码。需自己对接JS glue code。 生成文档 zig生成的文档，首先安装bun，然后在文档目录下执行命令bunx serve .。这是因为main.js里面需要借助http获取wasm，所以直接打开index.html没用。\n","date":"2025-06-20T10:36:14+08:00","image":"https://wujilingfeng.github.io/p/zig%E5%AE%9E%E6%88%98/nature_hu_e18e38c523eb116e.png","permalink":"https://wujilingfeng.github.io/p/zig%E5%AE%9E%E6%88%98/","title":"Zig实战"},{"content":"gltf文件格式介绍\ngltf文件格式\n","date":"2025-05-19T18:05:13+08:00","image":"https://wujilingfeng.github.io/p/gltf%E6%A0%BC%E5%BC%8F/jiari_hu_ac2d69a4c5121dcc.png","permalink":"https://wujilingfeng.github.io/p/gltf%E6%A0%BC%E5%BC%8F/","title":"Gltf格式"},{"content":"按照网址进行配置.\n对于zorin os等基于ubuntu的发行版本，需要修改sudo vim /etc/os-release , 把ID设置为ubuntu。\n1 2 3 sudo apt update wget https://repo.radeon.com/amdgpu-install/6.3.4/ubuntu/jammy/amdgpu-install_6.3.60304-1_all.deb sudo apt install ./amdgpu-install_6.3.60304-1_all.deb 然后运行\n1 amdgpu-install -y --usecase=graphics,rocm 这个网址告诉如何在ubuntu的仓库安装rocm\n","date":"2025-05-13T17:46:40+08:00","image":"https://wujilingfeng.github.io/p/minkowski%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/rain_hu_5b8a3ec5d31f3dc8.png","permalink":"https://wujilingfeng.github.io/p/minkowski%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0/","title":"Minkowski框架学习"},{"content":"","date":"2025-04-30T16:52:46+08:00","image":"https://wujilingfeng.github.io/p/futhark%E5%AD%A6%E4%B9%A0/jinshan_hu_da357d4670659311.png","permalink":"https://wujilingfeng.github.io/p/futhark%E5%AD%A6%E4%B9%A0/","title":"Futhark学习"},{"content":"\nhaskell一种基于算子思想（functional）编程语言,以前我也设想过一种基于算子思想的编程语言，因为数学中所有空间集合的作用都可以理解为算子\n学习haskell要避免工程繁杂概念的弊端，有时努力回想以前的数学概念代替工程概念是有好处的，首先工程概念名词繁杂不长久，而数学是所有学科(除了哲学)最长久的学科。(这种长久性是“知识成立”的时间)\n比如手机cpu的架构和勾股定理，勾股定理在欧式几何中成立，之后发现在其他几何中不成立，而手机cpu的架构只是工程架构，几个月后就发生改变或者优化。所以勾股定理比c语言，计算机，鸿霥，甚至牛顿力学还要长久，那么为什么不学习寿命更长久的知识而要学习繁杂短暂的知识?\n可以说未来属于算子类型语言cop,haskell，而不是工程类语言c,c++,java,python\u0026hellip;\n使用haskell不应关注效率，而是思想。计算机专业大量人士进入haskell语言领域，它们给haskell语言带来了实践能力的同时也给haskell语言带来了计算机工程行业的弊端:行业术语的工程化，繁杂化，不严谨化。本文是用数学的概念统一解释haskell的概念，希望给数学专业的人免去繁杂和不严谨的工程概念。\n万物皆算子，这样就不用记什么高阶函数，数据结构，递归数据结构，柯里化之类的概念。\n自带的算子\n算子 含义 :t a a的类型 == 是否等于，返回True False /= 是否不等于 :l hello 加载hello.hs文件 a ^ b 返回a的b次方 \u0026lt;= \u0026gt;= mod 取余 div 整除 even a a是否是偶数 odd a a是否是奇数 .和$ ($) :: (a -\u0026gt; b) -\u0026gt; a -\u0026gt; b 和(.) :: (b -\u0026gt; c) -\u0026gt; (a -\u0026gt; b) -\u0026gt; a -\u0026gt; c，详细解释见下 取出列表的前n个元素 map a [1,2..] 一种经典用法 map (*) [1,2..] \\ lambda算子,比如(\\xs -\u0026gt; length xs \u0026gt; 15),xs是参数，length xs \u0026gt; 15是body 3 数字3也是算子，它是常量算子 \u0026amp;\u0026amp; || not cos sin acos asin 有些算子有歧义可以类似如下调用\n1 2 3 read \u0026#34;5\u0026#34; :: Int read \u0026#34;5\u0026#34; :: Integer read \u0026#34;3.01\u0026#34; :: Float 由于-号也是算子,所以-1.0尽量加括号，变成(-1.0)\n函数本身也是算子\n1 2 map f []=[] map f (x:_)=f x:map f _ 上面的map函数也叫“高阶函数”，但是从万物皆算子的角度看，并不要这种多余概念。\nlambda算子举例\\(a,b,c)-\u0026gt; a+b-c\n两个内建的类型 列表:\n1 2 3 [1,2,3,4] --还有更简单的表示形式 [1..4] 1 2 3 4 5 6 7 head [1..4] last [1..4] length [1..4] maxmum [1..4] minmum [1..4] tail [1..4] [1..4]!!2 元组:\n1 [(a,b,c) | a\u0026lt;-[1..100],b\u0026lt;-[1..a],c\u0026lt;[1..b],c^2+b^2==a^2] 逻辑 1 2 3 4 if var 2==2 then putStrLn \u0026#34;oK\u0026#34; else putStrLn \u0026#34;not\u0026#34; 模式匹配 模式匹配用来泛化算子的表示能力\n1 2 3 4 5 6 7 addVectors ::(Num a)=\u0026gt; (a,a)-\u0026gt;(a,a)-\u0026gt;(a,a) addVectors (x1,y1) (x2,y2)=(x1+x2,y1+y2) ---作用在列表的算子 head\u0026#39; :: [a]-\u0026gt;a head\u0026#39; [] =error \u0026#34;cant \u0026#34; head\u0026#39; (x:x_)=x 1 2 3 4 --String也属于列表,其实代码是 type String=[Char],type类似c语言的typedef capital :: String -\u0026gt; String capital \u0026#34;\u0026#34; = \u0026#34;empty string\u0026#34; capital (x:xs) = \u0026#34;the first letter of \u0026#34; ++ x:xs ++ \u0026#34; is \u0026#34; ++ [x] 在上面的head\u0026rsquo;算子定义你肯定觉得haskell是有“潜规则”的，否则它是如何匹配返回列表头部算子的？所以你只能默认并记住这种列表匹配的规则。(也就是在模式匹配中(x:_)表示列表)。\n以下算子表示也比较隐蔽\n1 2 3 4 --x算子表示：x为常量1 x=1 --- 分别定义了x,y,z:算子，他们是常量 (x,y,z)=(0.1,2,-0.9) 上面看到Haskell的模式匹配条件相当松散。当算子定义合适时，如果输入类型不同的参数，它还是能正常运作。\n但是当参数的类型差异较大时，模式匹配不能分辨参数的类型，也自然无法使得算子定义可以接受不同类型的参数。这时我们需要针对不同的类型写不同的算子。这样的坏处是算子名不能统一。\n针对这种问题，haskell提出类型类的概念（见下）。\nhaskell的分段函数（类似c语言的case switch）\n1 2 3 4 5 bmiTell weight height | bmi \u0026lt;= 18.5 = \u0026#34;you\u0026#34; | bim \u0026lt;= 25.0 = \u0026#34;my\u0026#34; | otherwise = \u0026#34;d\u0026#34; where bim = weight/height^2 如果把条件语句放到后面就更像数学分段函数的表示\n分段函数还可以直接用在算子的表达式中\n1 2 3 fn a= let b |a==1 =0 | otherwise =1 in b let .. in ..(其中..等于..) 数学中常用的语句 “其中..等于..”。它的表示用来解释in单词后面的式子\n\u0026hellip; Where \u0026hellip;(其中..等于..) 数学中常用的语句 “其中..等于..”。它的表示用来解释单词where前的式子。\nwhere必须换行并回车，并且where之前的式子必须要是等式\n1 2 3 [let sq x=x*x in (sq 3,sq 4,sq 5)] --返回(9,16,25) let sq x=x*x in [sq 1,sq 2,sq 3] 1 2 a=[sq 3,sq 4,sq 5] where sq x=x* where的多个定义使用分号\n1 2 3 4 5 6 let {a x=g where g= p x x; p a b =a+b } 如果换a x=g为g,那么编译失败。\n两个简单的复合算子 foldr f a [a1,a2\u0026hellip;]\n上面的算子f是某个算子，如果记这个算子为*,那么结果就是 a1 * a2 *a3 .... *an * a\n有人翻译成右折叠，这增加了名词学习成本,比较恶心\nfoldl f a [a1,a2 \u0026hellip;]\n上面的算子f是某个算子，如果记这个算子为*,那么结果就是 a * a1 * a2 *a3 .... *an 有人翻译成左折叠，这增加了名词学习成本，比较恶心\n类型类\u0026ndash;算子类 如果你需要一些算子，它能接受的参数是多种类型的。那么你需要定义一个”类型类“（建议改名\u0026quot;函数类\u0026quot;或者“算子类”，因为它的主要作用就是扩展函数或算子的表达力）。\n比如我需要==算子，他需要能接受Float,Interger,Char等类型(或者输出为多种类型)。我那么我可以定义Myeq的类型类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 data Node a= Cons a (Node a) | NULL deriving (Show) class Myeq a where iseq :: a-\u0026gt;a-\u0026gt;Bool instance (Eq a)=\u0026gt;Myeq (Node a) where --iseq :: (Eq x)=\u0026gt; (Cons x _)-\u0026gt;(Cons x _)-\u0026gt;Bool iseq (Cons x _) (Cons y _)=(x==y) data Shape= Circle | Rectangle instance Myeq Shape where iseq Circle Rectangle=False iseq Rectangle Circle =False iseq Circle Circle=True iseq Rectangle Rectangle=True 故而类型类是为了拓展函数（算子）的泛化能力而存在的。它的核心含义是其下声明的函数(算子)。\nModule import qualified Data.Map as M\n这是python是一样的\n自定义算子类型 1 data Mybool = True | False True是算子，False也是算子，他们都是没有参数的，所以都是常量。Mybool是这两个算子所属的类型。\n1 data Shape=Circle Float Float | Rectangel Float Float Float Float 上面的Circle和Rectangel是两个算子，Circle作用两个参数,且这两个参数分属Float 类型。Shape则是两个算子所属的类型。\n上面虽然讲Haskell秉承万物皆算子，但是上面的Shape和Mybool却不是算子，实际上类型都不是算子，比如Integer（haskell没有把它看作算子，但是却看成函子，详细见下）。\n带参数的类型,这个参数表示的是类型。\n1 data Node a =Cons a (Node a) 这只有一个算子，那就是Cons 。它作用于两个参数,这两个参数属于类型 a和 (Node a)。系统找不到类型a的定义，自然表明它是任何类型，Node a则是引用了自身的定义。\nNode a是Cons算子属于的类型.\n上面讲Haskell没有把Shape等视为算子，但是Haskell却把Shape 和Node a等视为函子。因为它是类型到类型的映射，比如Shape 是常量 ,而Node 则是把类型a映射为 Node,即a-\u0026gt;Node a。Node a也是函子，只不过它是常量。\n所有类型都视为函子。\nhttps://www.cnblogs.com/livewithnorest/archive/2012/08/02/2620718.html)\n范畴和函子 这里是范畴和函子定义\n范畴 范畴C包含\u0026quot;物件\u0026quot;，记为obj(C)(比如拓扑空间的开集就是Hausdoff空间的物件) 范畴C包含态射或者箭头，改态射将物件a映射为物件b,记为$Hom_C \\left(a,b\\right)$ 范畴C,态射之间存在\u0026quot;作用\u0026quot;或者二元运算，称作态射的复合，这样的态射构成\u0026quot;幺半群（满足结合律和单位元）\u0026quot;。[^1] 函子 设C和D为范畴，函子F是C到D的映射，满足\n将C的每个物件$X\\in C$映射至$F\\left(X\\right)\\in D$上 将C的每个态射$f\\in Hom_C\\left(a,b\\right)$映射至$F\\left(f\\right)\\in Hom_D\\left(F\\left(a\\right),F\\left(b\\right)\\right)$ 将C的态射的单位元映射到D的态射单位元 对”态射构成的幺半群“是“同态”。1 按照定义范畴有一堆集合，和箭头。\n{% asset_img cate.png 范畴 %}\n函子是范畴和范畴之间集合的箭头\n{% asset_img functor.png 函子 %}\n如上图，假设A,B是范畴1的集合，C,D是范畴2的集合，A到C的箭头是函子，B到D的箭头是函子，那么从A到B的箭头可以诱导C到D的箭头。\n注意上面讲：类型类主要用来让函数（算子）接受不同类型的参数。\n数学上函子不但联系了两个范畴的对象，还将两个范畴的箭头进行联系。而Haskell的类型系统只是完成了两个范畴对象的对应(没有给出映射)。\n比如[Int]联系了集合Int 和 [Int],并没有映射，它们之间也没有映射。\nhaskell有个类型类Functor,这里的Functor主要解决两个对应类型之间的诱导映射。每一个类型都联系了两个类型（比如Int类型联系了Int到自身），这里的Functor（它的核心是算子fmap）主要解决类型诱导的映射问题。\n你已经注意到这里我说的函子都是数学上严格定义的函子，haskell的Functor虽然名字叫函子，它并非严格意义的函子，上面也说了：它是主要是解决类型诱导的映射。\n1 2 3 4 class Functor f where fmap:: (a-\u0026gt;a)-\u0026gt;f a-\u0026gt;f a instance Functor [] where fmap = map 单子 设有范畴C,T是$C\\to C$的函子，u是$c\\to TC$的函子，v是$TTC\\to TC$的函子，如果u，v满足$vTu=vuT=id$和$uTu=uuT:T^3C\\to TC$,那么称$\\left(T,u,v\\right)$是C的单子。\nhaskell语言单子与数学上单子不同，主要体现在不严谨性，比如现在的haskell 的Monad的return函数在$TC$上没有定义,整个函数也没有定义在$TTC$\u0026hellip;,而且函数式编程语言的定义:自函子上的幺半群并非数学上的定义，应该是编程语言自己加的结构。\n总结 总结来说，haskell的重要概念都是围绕两个元素服务的1:算子，2:函子。\n其中函子(数学上的严格定义)在haskell表现为:\n定义新的类型 \u0026mdash; 将范畴映射为另一范畴。（函子） \u0026ldquo;算子类\u0026rdquo;\u0026mdash;函子诱导的映射（不论是haskell的Functor,Manod都属于这一概念）。 本文也有弊端，一方面本文试图从数学角度统一解释，但是文章叙述确实参杂各种工程术语，并且文章也叙述了很细小的工程细节，希望以后能够修改本文。\n像haskell这一类语言简直是数学专业的神器，懊悔发现这门语言太晚！\nParallel and Concurrent Programming in Haskell[Book]\n加引号是因为复合这个作用并不能作用在所有态射上，而群是要求所有元素都可作用。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-04-29T10:58:01+08:00","image":"https://wujilingfeng.github.io/p/haskell%E5%AD%A6%E4%B9%A0/img_hu_1b7eaa217e0b240d.png","permalink":"https://wujilingfeng.github.io/p/haskell%E5%AD%A6%E4%B9%A0/","title":"Haskell学习"},{"content":"hugo 似乎的确存在很多bug。\nstack主题对于baseurl的路径处理有bug，例如当baseurl = https://wujilingfeng.github.io/myblog/时，生成的网页内容路径会自动添加myblog。\nstack主题对于文章的语言分类是以md的文件名中缀zh-cn,en,ar来进行区分的。\n","date":"2025-04-29T08:57:27+08:00","image":"https://wujilingfeng.github.io/p/hugo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/shumu_hu_dc6f308cae3ae0e5.png","permalink":"https://wujilingfeng.github.io/p/hugo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","title":"Hugo+github搭建博客"},{"content":"zig语言每个变量分为const 和var，结构体成员变量（除了静态变量）的const和var是和该结构体实例相同。\nzig语言对函数声明和定义启用延迟检查分析，也就是如果定义的函数未使用，zig编译器就不会分析检查该函数，也就更不会对该函数报错。\nzig语言的void和c语言的void不同，c语言的void对应anyopaque，是对opaque的泛化，就像anytype是对type的泛化，anyerror对error的泛化。void也是一个类型，它的值通常为{}。\nzig语言 的”元组“，.{\u0026ldquo;nihao\u0026rdquo;,3}其实是个value, 它的类型是匿名结构体，\nzig语言会自动对结构体的内存进行布局优化，下面的例子:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const RB_Node = struct { key: i32, left: ?*RB_Node, right: ?*RB_Node, parent: ?*RB_Node, color: bool, }; dprint(\u0026#34;rb node size:{}\\n\u0026#34;, .{@sizeOf(RB_Node)}); std.debug.print(\u0026#34;Size of RB_Node: {}\\n\u0026#34;, .{@sizeOf(RB_Node)}); std.debug.print(\u0026#34;Offset of key: {}\\n\u0026#34;, .{@offsetOf(RB_Node, \u0026#34;key\u0026#34;)}); std.debug.print(\u0026#34;Offset of left: {}\\n\u0026#34;, .{@offsetOf(RB_Node, \u0026#34;left\u0026#34;)}); std.debug.print(\u0026#34;Offset of right: {}\\n\u0026#34;, .{@offsetOf(RB_Node, \u0026#34;right\u0026#34;)}); std.debug.print(\u0026#34;Offset of parent: {}\\n\u0026#34;, .{@offsetOf(RB_Node, \u0026#34;parent\u0026#34;)}); std.debug.print(\u0026#34;Offset of color: {}\\n\u0026#34;, .{@offsetOf(RB_Node, \u0026#34;color\u0026#34;)}); zig语言的anytype只用于函数的参数声明（其他都不能用，函数的返回类型也不能用anytype,似乎zig内置函数可以）。\nzig 的test的函数必须是字符串，否则必须是标识符，一般和某个函数名的标识符相同，这样会作为该函数的文档测试说明。test函数的默认返回类型是错误联合类型，也就是!void\n这个网页说明了一些用法\n错误处理 zig语言的error类型会自动赋一个整数值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const FileOpenError = error{ AccessDenied, OutOfMemory, FileNotFound, }; const AllocationError = error{ OutOfMemory, }; pub fn main() !void { const errort = FileOpenError.OutOfMemory; const err_int = @intFromError(errort); const err_int1 = @intFromError(AllocationError.OutOfMemory); dprint(\u0026#34;value errot:{},{}\\n\u0026#34;, .{ err_int, err_int1 }); } zig语言的catch是个二元运算符,value = expression catch default_value;，含义：\n如果 expression 成功（返回 T 类型的值），则 value 被赋值为该值。 如果 expression 返回错误（error 类型），则 value 被赋值为 default_value。 如:\n1 const number = parseU64(str, 10) catch 13; 在 Zig 中，catch 还支持一种扩展形式，允许你在捕获错误时执行自定义逻辑。这种用法的语法是：\n1 2 value = expression catch |err| { /* handle error */ }; expression catch |err| return err;这个语句完全等价try。 错误联合类型可以用if语句解包，但必须包含else分支，否则报错，也可以用while解包，但也需要包含else分支，否则报错。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const a: anyerror!u32 = error.AlwaysError; if (a) |value| { std.debug.print(\u0026#34;type a{}\\n\u0026#34;, .{value}); // 处理正常值 } else |err| { std.debug.print(\u0026#34;type a{}\\n\u0026#34;, .{err}); // 处理错误（必须显式捕获err） } fn fetchData() anyerror!u32 { // 模拟可能失败的操作 return if (std.crypto.random.int(u32) % 2 == 0) 42 else error.FetchFailed; } pub fn main() void { var retry: u32 = 0; while (fetchData()) |data| { std.debug.print(\u0026#34;Data: {}\\n\u0026#34;, .{data}); retry += 1; if (retry \u0026gt;= 3) break; // 防止无限循环 } else |err| { std.debug.print(\u0026#34;Error: {}\\n\u0026#34;, .{err}); } } 上面的||捕获可以是|_|，即忽略捕获值。 可选联合类型 zig语言的orelse也是二元运算符，用来解包可选类型，左右两边两个表达式为执行代码，const b= a orelse value其中a是可选类型，b的值是当a不为null时，b为a的解包值，否则b为value。也可以用.?可访问非null的值（如果是null会引发panic）,if(optional_value)|value|是最安全的用法，while也可以解包可选类型。\nzig语言的return,break,continue,unreachable，while(true){}属于noreturn类型的值，用法基本和c一样，return用于全局退出，break用于局部退出。所以标签块要用break退出.\nzig语言的noreturn 可以和任何类型兼容，所以任何表达式都可以使用noreturn赋值，但因为是noreturn 类型，赋值操作不会执行，只会影响控制。\n下面是标签块的使用，\n1 2 3 4 5 6 var y: i32 = 123; const x = blk: { y += 1; break :blk y; }; 标记联合体 下面的@typeInfo返回的Type类型就是个union(enum)\n1 2 3 4 5 6 7 8 9 10 11 12 /// Checks if a `Ptr` is a pointer to `Item`. /// Note that the pointer is allowed to have the `const`, `volatile` or `allowzero` keyword. pub fn isSizeOnePoiner( comptime Item: type, comptime Ptr: type, ) bool { return switch (@typeInfo(Ptr)) { .pointer =\u0026gt; |p| p.size == .one and p.child == Item, else =\u0026gt; false, }; } 下面展示了枚举变量的简洁写法，\n1 2 3 4 5 const Color = enum { red, @\u0026#34;really red\u0026#34;, }; const color: Color = .@\u0026#34;really red\u0026#34;; 容器级别变量具有静态生命周期，且顺序无关，并且是惰性分析的。容器级别变量的初始化值隐式为编译时。如果容器级别变量是const，则其值在编译时已知，否则是在运行时已知。\n1 2 3 4 5 6 7 8 9 10 11 var y:i32=add(10,x); const x: i32=add(12,34); test \u0026#34;container level variables\u0026#34;{ try expect(x==46); try expect(y==56); } fn add(a:i32,b:i32) i32{ return a+b; } const std= @import(\u0026#34;std\u0026#34;) const expect= std.testing.expect; zig语言的const变量尽量会在编译器赋值或者初始化，尤其是在容器内的const变量只会在编译时赋值。\n如果想让var变量的初始化也在编译时进行，可以\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 test \u0026#34;comptime vars\u0026#34; { var x: i32 = 1; comptime var y: i32 = 1; x += 1; y += 1; try expect(x == 2); try expect(y == 2); if (y != 2) { // This compile error never triggers because y is a comptime variable, // and so `y != 2` is a comptime value, and this if is statically evaluated. @compileError(\u0026#34;wrong y value\u0026#34;); } } zig语言的切片和数组（array）的区别似乎只是固定长度和动态长度的区别。而且数组不能转化为指针和切片，只有数组的指针才能转化为切片和指向多个元素的指针。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const all_zero = [_]u16{0} ** 10; const Point = struct { x: i32, y: i32, }; test \u0026#34;compile-time array initialization\u0026#34; { try expect(fancy_array[4].x == 4); try expect(fancy_array[4].y == 8); } // call a function to initialize an array var more_points = [_]Point{makePoint(3)} ** 10; fn makePoint(x: i32) Point { return Point{ .x = x, .y = x * 2, }; } zig语言数组的初始化用法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const all_zero = [_]u16{0} ** 10; comptime { assert(all_zero.len == 10); assert(all_zero[5] == 0); } const Point = struct { x: i32, y: i32, }; test \u0026#34;compile-time array initialization\u0026#34; { try expect(fancy_array[4].x == 4); try expect(fancy_array[4].y == 8); } // call a function to initialize an array var more_points = [_]Point{makePoint(3)} ** 10; fn makePoint(x: i32) Point { return Point{ .x = x, .y = x * 2, }; } 虽然数组和切片更相似，但是切片和数组指针存在默认转换,数组的指针可以默认转化为切片，反之不行(除非在编译阶段能确定切片长度，这样就可以把切片默认转化为数组指针)。数组指针也可以转化为多项指针。\n1 2 3 4 5 6 7 8 9 10 11 const bytes: *const [5:0]u8 = \u0026#34;hello\u0026#34;; dprint(\u0026#34;bytes type:{}\\n\u0026#34;, .{@TypeOf(bytes)}); // const slice: []const u8 = \u0026#34;slice\u0026#34;; const slice: []const u8 = bytes;\\\\数组的指针转化为切片 dprint(\u0026#34;slice type:{}\\n\u0026#34;, .{@TypeOf(slice)}); const array: [5]u8 = [5]u8{ 1, 2, 3, 4, 5 }; const array_ptr = \u0026amp;array; dprint(\u0026#34;array type:{}\\n\u0026#34;, .{@TypeOf(array_ptr)}); const array_ptr1: [*]const u8 = \u0026amp;array;\\\\数组的指针转化为指向多个元素的指针。 dprint(\u0026#34;array type1:{}\\n\u0026#34;, .{@TypeOf(array_ptr1)}); 单个的指针ptr可以通过ptr[0..1]转化为切片（但是会在编译阶段优化为数组的指针）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 var sum2: i32 = 0; for (items, 0..) |_, i| { try expect(@TypeOf(i) == usize); sum2 += @as(i32, @intCast(i)); } test \u0026#34;switch simple\u0026#34; { const a: u64 = 10; const zz: u64 = 103; // All branches of a switch expression must be able to be coerced to a // common type. // // Branches cannot fallthrough. If fallthrough behavior is desired, combine // the cases and use an if. const b = switch (a) { // Multiple cases can be combined via a \u0026#39;,\u0026#39; 1, 2, 3 =\u0026gt; 0, // Ranges can be specified using the ... syntax. These are inclusive // of both ends. 5...100 =\u0026gt; 1, // Branches can be arbitrarily complex. 101 =\u0026gt; blk: { const c: u64 = 5; break :blk c * 2 + 1; }, // Switching on arbitrary expressions is allowed as long as the // expression is known at compile-time. zz =\u0026gt; zz, blk: { const d: u32 = 5; const e: u32 = 100; break :blk d + e; } =\u0026gt; 107, // The else branch catches everything not already captured. // Else branches are mandatory unless the entire range of values // is handled. else =\u0026gt; 9, }; try expect(b == 1); } 在 switch 中，范围使用了三个点，即 3...6，而这个示例中，范围使用了两个点，即 0..10。这是因为在 switch 中，范围的两端都是闭区间，而 for 则是左闭右开。\nzig语言的函数参数默认是const，即不能修改参数的值。\n逻辑流程控制 下面是while的用法，支持一个额外的每次运行的表达式。\n1 2 3 4 5 6 7 8 9 10 11 test \u0026#34;while loop continue expression, more complicated\u0026#34; { var i: usize = 1; var j: usize = 1; while (i * j \u0026lt; 2000) : ({ i *= 2; j *= 3; }) { const my_ij = i * j; try expect(my_ij \u0026lt; 2000); } } 其实while也是个表达式，它的值既可以是while循环里break value返回的value，也可以是else表达式返回的值.\n1 2 3 4 5 6 7 8 fn rangeHasNumber(begin: usize, end: usize, number: usize) bool { var i = begin; return while (i \u0026lt; end) : (i += 1) { if (i == number) { break true; } } else false; } 1 2 3 4 5 6 7 8 9 10 11 fn myfun()!void{ var buf: [30]u8 = undefined; //在这里try语句遇到错误会从终止函数并返回错误结果，因为stdin.readUntilDelimiterOrEof(\u0026amp;buf, \u0026#39;\\n\u0026#39;)的返回值类型为`!?[]u8`，所以 //if语句解包的是可选类型，得到|line| if (try stdin.readUntilDelimiterOrEof(\u0026amp;buf, \u0026#39;\\n\u0026#39;)) |line| { } } if else语句也可以当作表达式，如下:\n1 2 3 4 5 6 7 8 9 10 11 pub fn addpolynomials(self: *Self, p1: []T, p2: []T, result: ?[]T) ?[]T { const maxDegree = if (p1.len \u0026gt; p2.len) p1.len else p2.len; const re = if (result) |re1| if (re1.len \u0026lt; maxDegree) return null else re1 else self.allocator.alloc(T, maxDegree) catch return null; for (0..maxDegree) |i| { re[i] = (if (i \u0026lt; p1.len) p1[i] else 0) + (if (i \u0026lt; p2.len) p2[i] else 0); } return re; } 在函数的泛型参数中anytype和comptime T:type，在效率上似乎是一样的，comptime T更清晰但是接口更复杂，anytype接口简洁但是需要推导类型（@TypeOf）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const std = @import(\u0026#34;std\u0026#34;); const expect = std.testing.expect; const ComplexTypeTag = enum { ok, not_ok, }; const ComplexType = union(ComplexTypeTag) { ok: u8, not_ok: void, }; test \u0026#34;modify tagged union in switch\u0026#34; { var c = ComplexType{ .ok = 42 }; switch (c) { ComplexTypeTag.ok =\u0026gt; |*value| value.* += 1, ComplexTypeTag.not_ok =\u0026gt; unreachable, } try expect(c.ok == 43); } defer是在作用域退出时执行表达式，表达式当然可以是块（block）。defer , if , while,for ,switch关键字都是控制语句，后面如果是单个语句要加;, 如果是{}不加分号。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 onst std = @import(\u0026#34;std\u0026#34;); const expect = std.testing.expect; const print = std.debug.print; fn deferExample() !usize { var a: usize = 1; { defer a = 2; a = 1; } try expect(a == 2); a = 5; return a; } test \u0026#34;defer basics\u0026#34; { try expect((try deferExample()) == 5); } 内存分配器 std.testing.allocator是建议且只建议在test函数中使用的内存分配器。\n1 2 3 4 5 6 7 test \u0026#34;detect leak\u0026#34; { var list = std.ArrayList(u21).init(std.testing.allocator); // missing `defer list.deinit();` try list.append(\u0026#39;☔\u0026#39;); try std.testing.expect(list.items.len == 1); } 数值 在 Zig 语言中，‌低精度数值向高精度变量赋值时不需要显式转换，编译器会自动完成安全的隐式提升‌。\n在Zig语言中，‌高精度数值赋给低精度变量需要显式转换‌，否则会触发编译错误。@intCast、@truncate、@floatCast\nZig 模块导入核心规则 路径导入继承依赖：使用 @import(\u0026quot;./file.zig\u0026quot;) 导入文件时，该文件会自动继承父模块（即调用 @import 的模块）通过 addImport 添加的所有命名模块。这意味着，只要在 exe.root_module 中添加了依赖（如 addImport(\u0026quot;tracy\u0026quot;, tracy_mod)），所有通过路径导入的 .zig 文件都能直接使用 @import(\u0026quot;tracy\u0026quot;)。\n命名导入不传递依赖：通过 A.addImport(\u0026quot;B\u0026quot;, B_mod) 仅允许模块 A 访问 B。模块 B 不会自动继承 A 的其他依赖，依赖关系是单向的。若 B 也需要使用其他模块，必须显式为其添加 addImport。\n✅ 实践建议：在 build.zig 中，只需为 exe.root_module 添加一次 addImport，项目内所有通过相对路径导入的 .zig 文件即可共享这些依赖，无需为每个文件单独创建模块。这是构建大型项目的关键模式。\n额外说明 经过测试，结构体内部的函数和成员变量不能重名，block的标签名可以重名（除了嵌套）。\nzig的import导入模块的话，如果是直接@import 文件名的话，相对路径是相对于该导入文件的路径。\nzig的defer后面语句只能是void,也就是函数或者块不能返回值。\n风格指南\n请注意，下面的代码中a不是二维数组，它是一维数组，每个分量是切片。同理window_name是一维数组，由于切片，数组指针，指向多项的指针三者存在默认转换关系，所以window_name的每个分量是个指向多项的数组。\n1 2 const a=[_][]const u8{ \u0026#34;src\u0026#34;, \u0026#34;test\u0026#34;, \u0026#34;example\u0026#34; } const window_name = [1][*:0]const u8{\u0026#34;window name\u0026#34;}; zig语言的构建系统 zig语言的build.zig中，每个module或者test的root_source_file只能指向一个.zig文件（必须是相对路径），不可以是路径。\n示例：\n1 2 3 exe.addModule(\u0026#34;my_module\u0026#34;, .{ .root_source_file = .{ .path = \u0026#34;src/my_module\u0026#34; }, // 这里是目录 }); 然后在你的代码里可以这样用：\n1 2 const foo = @import(\u0026#34;my_module/foo.zig\u0026#34;); const bar = @import(\u0026#34;my_module/bar.zig\u0026#34;); 1. addModule 作用：创建一个模块，并将其添加到当前包的模块集合（b.modules）。\n可见性：公开（public）。这个模块会被暴露给依赖当前包的其他包（即作为 package 的“导出模块”）。\n典型用途：当你希望你的库/包对外暴露一个或多个模块时，使用 addModule。\n调用方式：\n1 const my_mod = b.addModule(\u0026#34;my_mod\u0026#34;, .{ .root_source_file = ... }); 效果：其他包可以通过 @import(\u0026quot;my_mod\u0026quot;) 访问这个模块。\n2. createModule 作用：创建一个模块，但不添加到包的模块集合，仅供当前包内部使用。 可见性：私有（private）。这个模块不会被暴露给依赖当前包的其他包。 典型用途：当你只需要在当前包内部组织代码、复用代码，但不希望对外暴露时，使用 createModule。 调用方式： 1 const my_private_mod = b.createModule(.{ .root_source_file = ... }); 效果：只能在当前包的 build 脚本中通过 addImport 等方式引用，外部包无法通过 @import 访问。 总结对比表 函数名 是否加入 b.modules 是否对外暴露 用途 addModule 是 是 对外暴露的模块 createModule 否 否 仅包内私有的模块 zig的编译系统中每个addTest和addExecutable都独立存在，哪怕它们指向同一个root_source_file，也就是有时多个文件内容test函数会多次运行。\nzig fetch zig fetch --save \u0026quot;git+https://github.com/用户/仓库.git#\u0026lt;commit_hash或者tag\u0026gt;\u0026quot;\n如果省掉#\u0026lt;commit_hash或者tag\u0026gt;就会拉取默认分支的最新的提交\n1 zig fetch --save=glfw \u0026#34;git+https://github.com/glfw/glfw.git\u0026#34; 下面测试也是可以的，但是不稳定，因为分支会变动\n1 zig fetch --save https://github.com/webui-dev/zig-webui/archive/main.tar.gz 如果自己手动填写url时，格式为\nhttps://github.com/\u0026lt;用户名\u0026gt;/\u0026lt;仓库名\u0026gt;/archive/\u0026lt;commit或tag\u0026gt;.tar.gz\n可以在build.zig中添加传递参数\n1 2 3 4 const exe = b.addExecutable(...); if (b.args) |args| { exe.addArgs(args); // 将构建参数传递给可执行文件 } 然后在程序中使用参数\n1 2 3 4 5 6 7 8 9 10 pub fn main() !void { const args = try std.process.argsAlloc(std.heap.page_allocator); defer std.process.argsFree(std.heap.page_allocator, args); // args[0]是程序名，args[1..]才是实际参数 for (args[1..]) |arg| { std.debug.print(\u0026#34;参数: {s}\\n\u0026#34;, .{arg}); } } 和外部（比如C）交互 1 2 3 4 5 6 7 8 9 10 const cstdio = @cImport({ // See https://github.com/ziglang/zig/issues/515 @cDefine(\u0026#34;_NO_CRT_STDIO_INLINE\u0026#34;, \u0026#34;1\u0026#34;); @cInclude(\u0026#34;stdio.h\u0026#34;); }); pub fn main() void{ _ = cstdio.printf(\u0026#34;hello\\n\u0026#34;); } 上面展示了引入c头文件的功能，需要在编译文件build.zig中添加exe.linkLibC();\nextern关键字表示在链接时才确定的符号，一般用在zig调用外部符号\n1 2 3 4 5 6 // extern声明用于声明将在链接时、静态链接时或运行时动态链接的函数。 // extern 关键字后的引号标识符指定具有该函数的库。（例如，“c”-\u0026gt;libc.so） // callconv 标记更改了函数的调用约定。 const WINAPI: std.builtin.CallingConvention = if (native_arch == .x86) .Stdcall else .C; extern \u0026#34;kernel32\u0026#34; fn ExitProcess(exit_code: u32) callconv(WINAPI) noreturn; extern \u0026#34;c\u0026#34; fn atan2(a: f64, b: f64) f64; ","date":"2025-04-28T00:00:00Z","image":"https://wujilingfeng.github.io/p/%E5%AD%A6%E4%B9%A0zig/fanchuan_hu_de82c3423caf9845.png","permalink":"https://wujilingfeng.github.io/p/%E5%AD%A6%E4%B9%A0zig/","title":"学习zig"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://wujilingfeng.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash.zh-cn_hu_2307260c751d0e0b.jpg","permalink":"https://wujilingfeng.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://wujilingfeng.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://wujilingfeng.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://wujilingfeng.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://wujilingfeng.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://wujilingfeng.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://wujilingfeng.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://wujilingfeng.github.io/p/emoji-support/","title":"Emoji Support"}]